/* byteonpanel.c generated by valac 0.16.1, the Vala compiler
 * generated from byteonpanel.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <stdio.h>
#include <glib/gstdio.h>
#include <cairo.h>
#include <gtk/gtk.h>
#include <config.h>
#include <gdk/gdk.h>
#include <gdk-pixbuf/gdk-pixbuf.h>


#define TYPE_BYTE_STAT (byte_stat_get_type ())
typedef struct _ByteStat ByteStat;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_IFACE (iface_get_type ())
#define IFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IFACE, IFace))
#define IFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IFACE, IFaceClass))
#define IS_IFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IFACE))
#define IS_IFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IFACE))
#define IFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IFACE, IFaceClass))

typedef struct _IFace IFace;
typedef struct _IFaceClass IFaceClass;
typedef struct _IFacePrivate IFacePrivate;
#define __g_queue_free__byte_stat_free0_0(var) ((var == NULL) ? NULL : (var = (_g_queue_free__byte_stat_free0_ (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _byte_stat_free0(var) ((var == NULL) ? NULL : (var = (byte_stat_free (var), NULL)))

#define TYPE_STATUS_ICON_IF (status_icon_if_get_type ())
#define STATUS_ICON_IF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_STATUS_ICON_IF, StatusIconIF))
#define STATUS_ICON_IF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_STATUS_ICON_IF, StatusIconIFClass))
#define IS_STATUS_ICON_IF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_STATUS_ICON_IF))
#define IS_STATUS_ICON_IF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_STATUS_ICON_IF))
#define STATUS_ICON_IF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_STATUS_ICON_IF, StatusIconIFClass))

typedef struct _StatusIconIF StatusIconIF;
typedef struct _StatusIconIFClass StatusIconIFClass;
typedef struct _StatusIconIFPrivate StatusIconIFPrivate;

#define TYPE_APPLICATION (application_get_type ())
#define APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_APPLICATION, Application))
#define APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_APPLICATION, ApplicationClass))
#define IS_APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_APPLICATION))
#define IS_APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_APPLICATION))
#define APPLICATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_APPLICATION, ApplicationClass))

typedef struct _Application Application;
typedef struct _ApplicationClass ApplicationClass;
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))

#define STATUS_ICON_IF_TYPE_TRANS_SPEED (status_icon_if_trans_speed_get_type ())
typedef struct _StatusIconIFTransSpeed StatusIconIFTransSpeed;
typedef struct _ApplicationPrivate ApplicationPrivate;
#define _g_tree_destroy0(var) ((var == NULL) ? NULL : (var = (g_tree_destroy (var), NULL)))
typedef struct _Block1Data Block1Data;

struct _ByteStat {
	gdouble time_stamp;
	guint64 rx_total;
	gdouble rx_speed;
	guint64 tx_total;
	gdouble tx_speed;
	gdouble total_speed;
};

struct _IFace {
	GObject parent_instance;
	IFacePrivate * priv;
	gchar* iface_id;
	guint maxlen;
	GQueue* flow_queue;
};

struct _IFaceClass {
	GObjectClass parent_class;
};

struct _IFacePrivate {
	gchar* iface_path;
	gchar* rx_path;
	gchar* tx_path;
	gchar* operstate_path;
	GTimeVal tval;
};

struct _StatusIconIF {
	GObject parent_instance;
	StatusIconIFPrivate * priv;
	IFace* iface;
	gfloat* rx_color;
	gint rx_color_length1;
	gfloat* tx_color;
	gint tx_color_length1;
	gfloat portion;
	gfloat portion_low;
	gfloat rate_low;
	guint update_timeout;
	guint update_scale_timeout;
};

struct _StatusIconIFClass {
	GObjectClass parent_class;
};

struct _StatusIconIFPrivate {
	Application* app;
	cairo_t* ctx;
	cairo_surface_t* surface;
	gdouble scale;
	GtkStatusIcon* statusicon;
	GtkMenu* menu;
	guint update_id;
	guint update_scale_id;
	gint margin;
};

struct _StatusIconIFTransSpeed {
	gdouble* rx_list;
	gint rx_list_length1;
	gint _rx_list_size_;
	gdouble* tx_list;
	gint tx_list_length1;
	gint _tx_list_size_;
};

struct _Application {
	GObject parent_instance;
	ApplicationPrivate * priv;
};

struct _ApplicationClass {
	GObjectClass parent_class;
};

struct _ApplicationPrivate {
	GTree* iface_map;
	guint iface_update_timeout;
	gulong about_response_id;
};

struct _Block1Data {
	int _ref_count_;
	Application * self;
	gchar** key2remove;
	gint key2remove_length1;
	gint _key2remove_size_;
};


static gpointer iface_parent_class = NULL;
static gpointer status_icon_if_parent_class = NULL;
static gpointer application_parent_class = NULL;

#define fdelta 1E-9
#define MAX_SLOT ((guint) 30)
#define MIN_STATUS_ICON_SIZE 16
#define SYS_NET_PATH "/sys/class/net"
GType byte_stat_get_type (void) G_GNUC_CONST;
ByteStat* byte_stat_dup (const ByteStat* self);
void byte_stat_free (ByteStat* self);
gchar* humanize_number (gdouble num, gfloat step, const gchar* unit_string);
GType iface_get_type (void) G_GNUC_CONST;
#define IFACE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_IFACE, IFacePrivate))
enum  {
	IFACE_DUMMY_PROPERTY,
	IFACE_ISUP
};
static void _byte_stat_free0_ (gpointer var);
static void _g_queue_free__byte_stat_free0_ (GQueue* self);
IFace* iface_new (const gchar* if_name);
IFace* iface_construct (GType object_type, const gchar* if_name);
void iface_update (IFace* self);
gboolean iface_get_isup (IFace* self);
static void iface_finalize (GObject* obj);
static void _vala_iface_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
GType status_icon_if_get_type (void) G_GNUC_CONST;
GType application_get_type (void) G_GNUC_CONST;
#define STATUS_ICON_IF_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_STATUS_ICON_IF, StatusIconIFPrivate))
enum  {
	STATUS_ICON_IF_DUMMY_PROPERTY
};
StatusIconIF* status_icon_if_new (Application* app_obj, IFace* iface_obj);
StatusIconIF* status_icon_if_construct (GType object_type, Application* app_obj, IFace* iface_obj);
static void status_icon_if_setup_icon (StatusIconIF* self);
static gboolean status_icon_if_on_status_icon_size_changed (StatusIconIF* self, GtkStatusIcon* sicon, gint size);
static gboolean _status_icon_if_on_status_icon_size_changed_gtk_status_icon_size_changed (GtkStatusIcon* _sender, gint size, gpointer self);
static void status_icon_if_setup_menu (StatusIconIF* self);
static void status_icon_if_on_popup_menu (StatusIconIF* self, guint button, guint atime);
void application_on_about_dialog_show (Application* self, GtkAction* act);
static void _application_on_about_dialog_show_gtk_action_activate (GtkAction* _sender, gpointer self);
void status_icon_if_on_quit (StatusIconIF* self, GtkAction* act);
static void _status_icon_if_on_quit_gtk_action_activate (GtkAction* _sender, gpointer self);
static void _status_icon_if_on_popup_menu_gtk_status_icon_popup_menu (GtkStatusIcon* _sender, guint button, guint activate_time, gpointer self);
static gchar* status_icon_if_make_tooltip (StatusIconIF* self);
static gdouble status_icon_if_max_total_speed (StatusIconIF* self, GQueue* somed);
gboolean status_icon_if_update_scale (StatusIconIF* self);
static GType status_icon_if_trans_speed_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static StatusIconIFTransSpeed* status_icon_if_trans_speed_dup (const StatusIconIFTransSpeed* self);
static void status_icon_if_trans_speed_free (StatusIconIFTransSpeed* self);
static void status_icon_if_trans_speed_copy (const StatusIconIFTransSpeed* self, StatusIconIFTransSpeed* dest);
static void status_icon_if_trans_speed_destroy (StatusIconIFTransSpeed* self);
static void status_icon_if_get_speed (StatusIconIF* self, gdouble max_speed, StatusIconIFTransSpeed* result);
static gdouble* _vala_array_dup1 (gdouble* self, int length);
static gdouble* _vala_array_dup2 (gdouble* self, int length);
gboolean status_icon_if_update (StatusIconIF* self);
static gdouble* _vala_array_dup3 (gdouble* self, int length);
static gdouble* _vala_array_dup4 (gdouble* self, int length);
void status_icon_if_start_timers (StatusIconIF* self);
static gboolean _status_icon_if_update_gsource_func (gpointer self);
static gboolean _status_icon_if_update_scale_gsource_func (gpointer self);
void application_quit (Application* self);
void status_icon_if_on_destroy (StatusIconIF* self);
static gdouble* _vala_array_dup5 (gdouble* self, int length);
static gdouble* _vala_array_dup6 (gdouble* self, int length);
static void status_icon_if_finalize (GObject* obj);
#define APPLICATION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_APPLICATION, ApplicationPrivate))
enum  {
	APPLICATION_DUMMY_PROPERTY
};
static Application* application_new (void);
static Application* application_construct (GType object_type);
static gint __lambda2_ (Application* self, const gchar* a, const gchar* b);
static gint ___lambda2__gcompare_data_func (gconstpointer a, gconstpointer b, gpointer self);
static gboolean application_update_iface (Application* self);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static gint __lambda3_ (Block1Data* _data1_, void* k, void* v);
static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value);
static gint ___lambda3__gtraverse_func (void* key, void* value, gpointer self);
static void __lambda4_ (Application* self, GtkDialog* a, gint b);
static void ___lambda4__gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self);
void application_start (Application* self);
static gboolean _application_update_iface_gsource_func (gpointer self);
gint application_main (gchar** args, int args_length1);
static void application_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


ByteStat* byte_stat_dup (const ByteStat* self) {
	ByteStat* dup;
	dup = g_new0 (ByteStat, 1);
	memcpy (dup, self, sizeof (ByteStat));
	return dup;
}


void byte_stat_free (ByteStat* self) {
	g_free (self);
}


GType byte_stat_get_type (void) {
	static volatile gsize byte_stat_type_id__volatile = 0;
	if (g_once_init_enter (&byte_stat_type_id__volatile)) {
		GType byte_stat_type_id;
		byte_stat_type_id = g_boxed_type_register_static ("ByteStat", (GBoxedCopyFunc) byte_stat_dup, (GBoxedFreeFunc) byte_stat_free);
		g_once_init_leave (&byte_stat_type_id__volatile, byte_stat_type_id);
	}
	return byte_stat_type_id__volatile;
}


gchar* humanize_number (gdouble num, gfloat step, const gchar* unit_string) {
	gchar* result = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar** _tmp9_ = NULL;
	gchar** ends;
	gint ends_length1;
	gint _ends_size_;
	gchar** _tmp10_;
	gint _tmp10__length1;
	gchar** _tmp11_;
	gint _tmp11__length1;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	gchar* the_end;
	gchar** _tmp14_;
	gint _tmp14__length1;
	gdouble _tmp22_;
	const gchar* _tmp23_;
	const gchar* _tmp24_;
	gchar* _tmp25_ = NULL;
	g_return_val_if_fail (unit_string != NULL, NULL);
	_tmp0_ = g_strdup ("");
	_tmp1_ = g_strdup ("K");
	_tmp2_ = g_strdup ("M");
	_tmp3_ = g_strdup ("G");
	_tmp4_ = g_strdup ("T");
	_tmp5_ = g_strdup ("P");
	_tmp6_ = g_strdup ("E");
	_tmp7_ = g_strdup ("Z");
	_tmp8_ = g_strdup ("Y");
	_tmp9_ = g_new0 (gchar*, 9 + 1);
	_tmp9_[0] = _tmp0_;
	_tmp9_[1] = _tmp1_;
	_tmp9_[2] = _tmp2_;
	_tmp9_[3] = _tmp3_;
	_tmp9_[4] = _tmp4_;
	_tmp9_[5] = _tmp5_;
	_tmp9_[6] = _tmp6_;
	_tmp9_[7] = _tmp7_;
	_tmp9_[8] = _tmp8_;
	ends = _tmp9_;
	ends_length1 = 9;
	_ends_size_ = ends_length1;
	_tmp10_ = ends;
	_tmp10__length1 = ends_length1;
	_tmp11_ = ends;
	_tmp11__length1 = ends_length1;
	_tmp12_ = _tmp10_[_tmp11__length1 - 1];
	_tmp13_ = g_strdup (_tmp12_);
	the_end = _tmp13_;
	_tmp14_ = ends;
	_tmp14__length1 = ends_length1;
	{
		gchar** i_collection = NULL;
		gint i_collection_length1 = 0;
		gint _i_collection_size_ = 0;
		gint i_it = 0;
		i_collection = _tmp14_;
		i_collection_length1 = _tmp14__length1;
		for (i_it = 0; i_it < _tmp14__length1; i_it = i_it + 1) {
			gchar* _tmp15_;
			gchar* i = NULL;
			_tmp15_ = g_strdup (i_collection[i_it]);
			i = _tmp15_;
			{
				gdouble _tmp16_;
				gfloat _tmp17_;
				gdouble _tmp20_;
				gfloat _tmp21_;
				_tmp16_ = num;
				_tmp17_ = step;
				if (_tmp16_ < ((gdouble) _tmp17_)) {
					const gchar* _tmp18_;
					gchar* _tmp19_;
					_tmp18_ = i;
					_tmp19_ = g_strdup (_tmp18_);
					_g_free0 (the_end);
					the_end = _tmp19_;
					_g_free0 (i);
					break;
				}
				_tmp20_ = num;
				_tmp21_ = step;
				num = _tmp20_ / _tmp21_;
				_g_free0 (i);
			}
		}
	}
	_tmp22_ = num;
	_tmp23_ = the_end;
	_tmp24_ = unit_string;
	_tmp25_ = g_strdup_printf ("%.2f%s%s", _tmp22_, _tmp23_, _tmp24_);
	result = _tmp25_;
	_g_free0 (the_end);
	ends = (_vala_array_free (ends, ends_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static void _byte_stat_free0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (byte_stat_free (var), NULL));
}


static void _g_queue_free__byte_stat_free0_ (GQueue* self) {
	g_queue_foreach (self, (GFunc) _byte_stat_free0_, NULL);
	g_queue_free (self);
}


IFace* iface_construct (GType object_type, const gchar* if_name) {
	IFace * self = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	const gchar* _tmp4_;
	gchar* _tmp5_ = NULL;
	const gchar* _tmp6_;
	gchar* _tmp7_ = NULL;
	const gchar* _tmp8_;
	gchar* _tmp9_ = NULL;
	GQueue* _tmp10_;
	g_return_val_if_fail (if_name != NULL, NULL);
	self = (IFace*) g_object_new (object_type, NULL);
	_tmp0_ = if_name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->iface_id);
	self->iface_id = _tmp1_;
	_tmp2_ = self->iface_id;
	_tmp3_ = g_build_filename (SYS_NET_PATH, _tmp2_, NULL);
	_g_free0 (self->priv->iface_path);
	self->priv->iface_path = _tmp3_;
	_tmp4_ = self->priv->iface_path;
	_tmp5_ = g_build_filename (_tmp4_, "statistics", "rx_bytes", NULL);
	_g_free0 (self->priv->rx_path);
	self->priv->rx_path = _tmp5_;
	_tmp6_ = self->priv->iface_path;
	_tmp7_ = g_build_filename (_tmp6_, "statistics", "tx_bytes", NULL);
	_g_free0 (self->priv->tx_path);
	self->priv->tx_path = _tmp7_;
	_tmp8_ = self->priv->iface_path;
	_tmp9_ = g_build_filename (_tmp8_, "operstate", NULL);
	_g_free0 (self->priv->operstate_path);
	self->priv->operstate_path = _tmp9_;
	_tmp10_ = g_queue_new ();
	__g_queue_free__byte_stat_free0_0 (self->flow_queue);
	self->flow_queue = _tmp10_;
	g_get_current_time (&self->priv->tval);
	return self;
}


IFace* iface_new (const gchar* if_name) {
	return iface_construct (TYPE_IFACE, if_name);
}


static guint64 uint64_parse (const gchar* str) {
	guint64 result = 0ULL;
	const gchar* _tmp0_;
	guint64 _tmp1_ = 0ULL;
	g_return_val_if_fail (str != NULL, 0ULL);
	_tmp0_ = str;
	_tmp1_ = g_ascii_strtoull (_tmp0_, NULL, (guint) 0);
	result = _tmp1_;
	return result;
}


static gpointer _byte_stat_dup0 (gpointer self) {
	return self ? byte_stat_dup (self) : NULL;
}


void iface_update (IFace* self) {
	gdouble time_stamp = 0.0;
	gdouble rx_rate = 0.0;
	gdouble tx_rate = 0.0;
	gdouble _tmp0_;
	guint64 rx = 0ULL;
	guint64 tx = 0ULL;
	GTimeVal _tmp26_;
	glong _tmp27_;
	GTimeVal _tmp28_;
	glong _tmp29_;
	GQueue* _tmp30_;
	gconstpointer _tmp31_ = NULL;
	ByteStat* _tmp32_;
	ByteStat* last_stat;
	GQueue* _tmp33_;
	guint _tmp34_;
	gdouble _tmp47_;
	guint64 _tmp48_;
	gdouble _tmp49_;
	guint64 _tmp50_;
	gdouble _tmp51_;
	gdouble _tmp52_;
	gdouble _tmp53_;
	ByteStat _tmp54_ = {0};
	ByteStat item;
	GQueue* _tmp55_;
	ByteStat _tmp56_;
	ByteStat* _tmp57_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	tx_rate = (gdouble) 0;
	_tmp0_ = tx_rate;
	rx_rate = _tmp0_;
	{
		guint8* _tmp1_ = NULL;
		guint8* rx_buf;
		gint rx_buf_length1;
		gint _rx_buf_size_;
		guint8* _tmp2_ = NULL;
		guint8* tx_buf;
		gint tx_buf_length1;
		gint _tx_buf_size_;
		gsize rlen = 0UL;
		const gchar* _tmp3_;
		GFile* _tmp4_ = NULL;
		GFile* fd;
		GFile* _tmp5_;
		GFileInputStream* _tmp6_ = NULL;
		GFileInputStream* rx_stream;
		const gchar* _tmp7_;
		GFile* _tmp8_ = NULL;
		GFile* _tmp9_;
		GFileInputStream* _tmp10_ = NULL;
		GFileInputStream* tx_stream;
		GFileInputStream* _tmp11_;
		guint8* _tmp12_;
		gint _tmp12__length1;
		gsize _tmp13_ = 0UL;
		GFileInputStream* _tmp14_;
		guint8* _tmp15_;
		gint _tmp15__length1;
		gsize _tmp16_ = 0UL;
		GFileInputStream* _tmp17_;
		GFileInputStream* _tmp18_;
		guint8* _tmp19_;
		gint _tmp19__length1;
		guint64 _tmp20_ = 0ULL;
		guint8* _tmp21_;
		gint _tmp21__length1;
		guint64 _tmp22_ = 0ULL;
		_tmp1_ = g_new0 (guint8, 64);
		rx_buf = _tmp1_;
		rx_buf_length1 = 64;
		_rx_buf_size_ = rx_buf_length1;
		_tmp2_ = g_new0 (guint8, 64);
		tx_buf = _tmp2_;
		tx_buf_length1 = 64;
		_tx_buf_size_ = tx_buf_length1;
		_tmp3_ = self->priv->rx_path;
		_tmp4_ = g_file_new_for_path (_tmp3_);
		fd = _tmp4_;
		_tmp5_ = fd;
		_tmp6_ = g_file_read (_tmp5_, NULL, &_inner_error_);
		rx_stream = _tmp6_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (fd);
			tx_buf = (g_free (tx_buf), NULL);
			rx_buf = (g_free (rx_buf), NULL);
			goto __catch0_g_error;
		}
		_tmp7_ = self->priv->tx_path;
		_tmp8_ = g_file_new_for_path (_tmp7_);
		_g_object_unref0 (fd);
		fd = _tmp8_;
		_tmp9_ = fd;
		_tmp10_ = g_file_read (_tmp9_, NULL, &_inner_error_);
		tx_stream = _tmp10_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (rx_stream);
			_g_object_unref0 (fd);
			tx_buf = (g_free (tx_buf), NULL);
			rx_buf = (g_free (rx_buf), NULL);
			goto __catch0_g_error;
		}
		g_get_current_time (&self->priv->tval);
		_tmp11_ = rx_stream;
		_tmp12_ = rx_buf;
		_tmp12__length1 = rx_buf_length1;
		g_input_stream_read_all ((GInputStream*) _tmp11_, _tmp12_, (gsize) _tmp12__length1, &_tmp13_, NULL, &_inner_error_);
		rlen = _tmp13_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (tx_stream);
			_g_object_unref0 (rx_stream);
			_g_object_unref0 (fd);
			tx_buf = (g_free (tx_buf), NULL);
			rx_buf = (g_free (rx_buf), NULL);
			goto __catch0_g_error;
		}
		_tmp14_ = tx_stream;
		_tmp15_ = tx_buf;
		_tmp15__length1 = tx_buf_length1;
		g_input_stream_read_all ((GInputStream*) _tmp14_, _tmp15_, (gsize) _tmp15__length1, &_tmp16_, NULL, &_inner_error_);
		rlen = _tmp16_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (tx_stream);
			_g_object_unref0 (rx_stream);
			_g_object_unref0 (fd);
			tx_buf = (g_free (tx_buf), NULL);
			rx_buf = (g_free (rx_buf), NULL);
			goto __catch0_g_error;
		}
		_tmp17_ = rx_stream;
		g_input_stream_close ((GInputStream*) _tmp17_, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (tx_stream);
			_g_object_unref0 (rx_stream);
			_g_object_unref0 (fd);
			tx_buf = (g_free (tx_buf), NULL);
			rx_buf = (g_free (rx_buf), NULL);
			goto __catch0_g_error;
		}
		_tmp18_ = tx_stream;
		g_input_stream_close ((GInputStream*) _tmp18_, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (tx_stream);
			_g_object_unref0 (rx_stream);
			_g_object_unref0 (fd);
			tx_buf = (g_free (tx_buf), NULL);
			rx_buf = (g_free (rx_buf), NULL);
			goto __catch0_g_error;
		}
		_tmp19_ = rx_buf;
		_tmp19__length1 = rx_buf_length1;
		_tmp20_ = uint64_parse ((const gchar*) _tmp19_);
		rx = _tmp20_;
		_tmp21_ = tx_buf;
		_tmp21__length1 = tx_buf_length1;
		_tmp22_ = uint64_parse ((const gchar*) _tmp21_);
		tx = _tmp22_;
		_g_object_unref0 (tx_stream);
		_g_object_unref0 (rx_stream);
		_g_object_unref0 (fd);
		tx_buf = (g_free (tx_buf), NULL);
		rx_buf = (g_free (rx_buf), NULL);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		FILE* _tmp23_;
		GError* _tmp24_;
		const gchar* _tmp25_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp23_ = stderr;
		_tmp24_ = e;
		_tmp25_ = _tmp24_->message;
		fprintf (_tmp23_, "Error: %s\n", _tmp25_);
		_g_error_free0 (e);
		return;
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp26_ = self->priv->tval;
	_tmp27_ = _tmp26_.tv_sec;
	_tmp28_ = self->priv->tval;
	_tmp29_ = _tmp28_.tv_usec;
	time_stamp = _tmp27_ + (_tmp29_ / 1000000.0);
	_tmp30_ = self->flow_queue;
	_tmp31_ = g_queue_peek_tail (_tmp30_);
	_tmp32_ = _byte_stat_dup0 ((ByteStat*) _tmp31_);
	last_stat = _tmp32_;
	_tmp33_ = self->flow_queue;
	_tmp34_ = _tmp33_->length;
	if (_tmp34_ > ((guint) 1)) {
		gdouble _tmp35_;
		ByteStat* _tmp36_;
		gdouble _tmp37_;
		gdouble laps;
		gdouble _tmp38_;
		_tmp35_ = time_stamp;
		_tmp36_ = last_stat;
		_tmp37_ = (*_tmp36_).time_stamp;
		laps = _tmp35_ - _tmp37_;
		_tmp38_ = laps;
		if (_tmp38_ == 0.0) {
			rx_rate = 0.0;
			tx_rate = 0.0;
		} else {
			guint64 _tmp39_;
			ByteStat* _tmp40_;
			guint64 _tmp41_;
			gdouble _tmp42_;
			guint64 _tmp43_;
			ByteStat* _tmp44_;
			guint64 _tmp45_;
			gdouble _tmp46_;
			_tmp39_ = rx;
			_tmp40_ = last_stat;
			_tmp41_ = (*_tmp40_).rx_total;
			_tmp42_ = laps;
			rx_rate = (_tmp39_ - _tmp41_) / _tmp42_;
			_tmp43_ = tx;
			_tmp44_ = last_stat;
			_tmp45_ = (*_tmp44_).tx_total;
			_tmp46_ = laps;
			tx_rate = (_tmp43_ - _tmp45_) / _tmp46_;
		}
	}
	_tmp47_ = time_stamp;
	_tmp48_ = rx;
	_tmp49_ = rx_rate;
	_tmp50_ = tx;
	_tmp51_ = tx_rate;
	_tmp52_ = rx_rate;
	_tmp53_ = tx_rate;
	_tmp54_.time_stamp = _tmp47_;
	_tmp54_.rx_total = _tmp48_;
	_tmp54_.rx_speed = _tmp49_;
	_tmp54_.tx_total = _tmp50_;
	_tmp54_.tx_speed = _tmp51_;
	_tmp54_.total_speed = _tmp52_ + _tmp53_;
	item = _tmp54_;
	_tmp55_ = self->flow_queue;
	_tmp56_ = item;
	_tmp57_ = _byte_stat_dup0 (&_tmp56_);
	g_queue_push_tail (_tmp55_, _tmp57_);
	while (TRUE) {
		GQueue* _tmp58_;
		guint _tmp59_;
		guint _tmp60_;
		GQueue* _tmp61_;
		gpointer _tmp62_ = NULL;
		ByteStat* _tmp63_;
		_tmp58_ = self->flow_queue;
		_tmp59_ = _tmp58_->length;
		_tmp60_ = self->maxlen;
		if (!(_tmp59_ > _tmp60_)) {
			break;
		}
		_tmp61_ = self->flow_queue;
		_tmp62_ = g_queue_pop_head (_tmp61_);
		_tmp63_ = (ByteStat*) _tmp62_;
		_byte_stat_free0 (_tmp63_);
	}
	_byte_stat_free0 (last_stat);
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _result_;
	const gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strstrip (_tmp1_);
	result = _result_;
	return result;
}


gboolean iface_get_isup (IFace* self) {
	gboolean result;
	gchar* text = NULL;
	const gchar* _tmp5_;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_;
	gboolean _tmp10_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	{
		const gchar* _tmp0_;
		gchar* _tmp1_ = NULL;
		_tmp0_ = self->priv->operstate_path;
		g_file_get_contents (_tmp0_, &_tmp1_, NULL, &_inner_error_);
		_g_free0 (text);
		text = _tmp1_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch1_g_file_error;
			}
			_g_free0 (text);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	goto __finally1;
	__catch1_g_file_error:
	{
		GError* e = NULL;
		FILE* _tmp2_;
		GError* _tmp3_;
		const gchar* _tmp4_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = stderr;
		_tmp3_ = e;
		_tmp4_ = _tmp3_->message;
		fprintf (_tmp2_, "Error: %s\n", _tmp4_);
		result = FALSE;
		_g_error_free0 (e);
		_g_free0 (text);
		return result;
	}
	__finally1:
	if (_inner_error_ != NULL) {
		_g_free0 (text);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	_tmp5_ = text;
	_tmp6_ = string_strip (_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = g_utf8_strdown (_tmp7_, (gssize) (-1));
	_tmp9_ = _tmp8_;
	_tmp10_ = g_strcmp0 (_tmp9_, "up") == 0;
	_g_free0 (_tmp9_);
	_g_free0 (_tmp7_);
	result = _tmp10_;
	_g_free0 (text);
	return result;
}


static void iface_class_init (IFaceClass * klass) {
	iface_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (IFacePrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_iface_get_property;
	G_OBJECT_CLASS (klass)->finalize = iface_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), IFACE_ISUP, g_param_spec_boolean ("isup", "isup", "isup", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void iface_instance_init (IFace * self) {
	self->priv = IFACE_GET_PRIVATE (self);
	self->maxlen = MAX_SLOT;
}


static void iface_finalize (GObject* obj) {
	IFace * self;
	self = IFACE (obj);
	_g_free0 (self->priv->iface_path);
	_g_free0 (self->priv->rx_path);
	_g_free0 (self->priv->tx_path);
	_g_free0 (self->priv->operstate_path);
	_g_free0 (self->iface_id);
	__g_queue_free__byte_stat_free0_0 (self->flow_queue);
	G_OBJECT_CLASS (iface_parent_class)->finalize (obj);
}


GType iface_get_type (void) {
	static volatile gsize iface_type_id__volatile = 0;
	if (g_once_init_enter (&iface_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IFaceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) iface_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IFace), 0, (GInstanceInitFunc) iface_instance_init, NULL };
		GType iface_type_id;
		iface_type_id = g_type_register_static (G_TYPE_OBJECT, "IFace", &g_define_type_info, 0);
		g_once_init_leave (&iface_type_id__volatile, iface_type_id);
	}
	return iface_type_id__volatile;
}


static void _vala_iface_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	IFace * self;
	self = IFACE (object);
	switch (property_id) {
		case IFACE_ISUP:
		g_value_set_boolean (value, iface_get_isup (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


StatusIconIF* status_icon_if_construct (GType object_type, Application* app_obj, IFace* iface_obj) {
	StatusIconIF * self = NULL;
	Application* _tmp0_;
	Application* _tmp1_;
	IFace* _tmp2_;
	IFace* _tmp3_;
	guint _tmp4_;
	g_return_val_if_fail (app_obj != NULL, NULL);
	g_return_val_if_fail (iface_obj != NULL, NULL);
	self = (StatusIconIF*) g_object_new (object_type, NULL);
	_tmp0_ = app_obj;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->app);
	self->priv->app = _tmp1_;
	_tmp2_ = iface_obj;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (self->iface);
	self->iface = _tmp3_;
	_tmp4_ = self->update_timeout;
	self->update_scale_timeout = MAX_SLOT * _tmp4_;
	status_icon_if_setup_icon (self);
	return self;
}


StatusIconIF* status_icon_if_new (Application* app_obj, IFace* iface_obj) {
	return status_icon_if_construct (TYPE_STATUS_ICON_IF, app_obj, iface_obj);
}


static gboolean _status_icon_if_on_status_icon_size_changed_gtk_status_icon_size_changed (GtkStatusIcon* _sender, gint size, gpointer self) {
	gboolean result;
	result = status_icon_if_on_status_icon_size_changed (self, _sender, size);
	return result;
}


static void status_icon_if_setup_icon (StatusIconIF* self) {
	GtkStatusIcon* _tmp0_;
	GtkStatusIcon* _tmp1_;
	GtkStatusIcon* _tmp2_;
	GtkStatusIcon* _tmp3_;
	GtkStatusIcon* _tmp4_;
	gboolean _tmp5_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_status_icon_new ();
	_g_object_unref0 (self->priv->statusicon);
	self->priv->statusicon = _tmp0_;
	_tmp1_ = self->priv->statusicon;
	gtk_status_icon_set_visible (_tmp1_, TRUE);
	_tmp2_ = self->priv->statusicon;
	gtk_status_icon_set_title (_tmp2_, PACKAGE_NAME);
	_tmp3_ = self->priv->statusicon;
	g_signal_connect_object (_tmp3_, "size-changed", (GCallback) _status_icon_if_on_status_icon_size_changed_gtk_status_icon_size_changed, self, 0);
	status_icon_if_setup_menu (self);
	_tmp4_ = self->priv->statusicon;
	_tmp5_ = gtk_status_icon_is_embedded (_tmp4_);
	if (_tmp5_) {
		GtkStatusIcon* _tmp6_;
		gint _tmp7_ = 0;
		gint size;
		gint _tmp8_;
		gint hsize;
		gint _tmp9_;
		gint _tmp12_;
		gint _tmp13_;
		cairo_surface_t* _tmp14_;
		cairo_surface_t* _tmp15_;
		cairo_t* _tmp16_;
		_tmp6_ = self->priv->statusicon;
		_tmp7_ = gtk_status_icon_get_size (_tmp6_);
		size = _tmp7_;
		_tmp8_ = size;
		hsize = _tmp8_;
		_tmp9_ = size;
		if (_tmp9_ >= MIN_STATUS_ICON_SIZE) {
			gint _tmp10_;
			gint _tmp11_;
			_tmp10_ = size;
			_tmp11_ = self->priv->margin;
			hsize = _tmp10_ - (_tmp11_ * 2);
		}
		_tmp12_ = size;
		_tmp13_ = hsize;
		_tmp14_ = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, _tmp12_, _tmp13_);
		_cairo_surface_destroy0 (self->priv->surface);
		self->priv->surface = _tmp14_;
		_tmp15_ = self->priv->surface;
		_tmp16_ = cairo_create (_tmp15_);
		_cairo_destroy0 (self->priv->ctx);
		self->priv->ctx = _tmp16_;
	}
}


static gboolean status_icon_if_on_status_icon_size_changed (StatusIconIF* self, GtkStatusIcon* sicon, gint size) {
	gboolean result = FALSE;
	GtkStatusIcon* _tmp0_;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (sicon != NULL, FALSE);
	_tmp0_ = self->priv->statusicon;
	_tmp1_ = gtk_status_icon_is_embedded (_tmp0_);
	if (_tmp1_) {
		gint _tmp2_;
		gint hsize;
		gint _tmp3_;
		gint _tmp6_;
		gint _tmp7_;
		cairo_surface_t* _tmp8_;
		cairo_surface_t* _tmp9_;
		cairo_t* _tmp10_;
		_tmp2_ = size;
		hsize = _tmp2_;
		_tmp3_ = size;
		if (_tmp3_ >= MIN_STATUS_ICON_SIZE) {
			gint _tmp4_;
			gint _tmp5_;
			_tmp4_ = size;
			_tmp5_ = self->priv->margin;
			hsize = _tmp4_ - (_tmp5_ * 2);
		}
		_tmp6_ = size;
		_tmp7_ = hsize;
		_tmp8_ = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, _tmp6_, _tmp7_);
		_cairo_surface_destroy0 (self->priv->surface);
		self->priv->surface = _tmp8_;
		_tmp9_ = self->priv->surface;
		_tmp10_ = cairo_create (_tmp9_);
		_cairo_destroy0 (self->priv->ctx);
		self->priv->ctx = _tmp10_;
	}
	result = TRUE;
	return result;
}


static void status_icon_if_on_popup_menu (StatusIconIF* self, guint button, guint atime) {
	GtkMenu* _tmp0_;
	guint _tmp1_;
	guint _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->menu;
	_tmp1_ = button;
	_tmp2_ = atime;
	gtk_menu_popup (_tmp0_, NULL, NULL, NULL, NULL, _tmp1_, (guint32) _tmp2_);
}


static void _application_on_about_dialog_show_gtk_action_activate (GtkAction* _sender, gpointer self) {
	application_on_about_dialog_show (self, _sender);
}


static void _status_icon_if_on_quit_gtk_action_activate (GtkAction* _sender, gpointer self) {
	status_icon_if_on_quit (self, _sender);
}


static void _status_icon_if_on_popup_menu_gtk_status_icon_popup_menu (GtkStatusIcon* _sender, guint button, guint activate_time, gpointer self) {
	status_icon_if_on_popup_menu (self, button, activate_time);
}


static void status_icon_if_setup_menu (StatusIconIF* self) {
	static const char ui_info[] = "\n" \
"            <ui>\n" \
"                <popup name=\"Popup\">\n" \
"                    <menuitem action=\"About\"/>\n" \
"                    <separator/>\n" \
"                    <menuitem action=\"Quit\"/>\n" \
"                </popup>\n" \
"            </ui>\n" \
"        ";
	GtkActionGroup* _tmp0_;
	GtkActionGroup* actions;
	GtkAction* action = NULL;
	GtkAction* _tmp1_;
	GtkAction* _tmp2_;
	Application* _tmp3_;
	GtkActionGroup* _tmp4_;
	GtkAction* _tmp5_;
	GtkAction* _tmp6_;
	GtkAction* _tmp7_;
	GtkActionGroup* _tmp8_;
	GtkAction* _tmp9_;
	GtkUIManager* _tmp10_;
	GtkUIManager* ui;
	GtkUIManager* _tmp11_;
	GtkActionGroup* _tmp12_;
	GtkUIManager* _tmp17_;
	GtkWidget* _tmp18_ = NULL;
	GtkMenu* _tmp19_;
	GtkStatusIcon* _tmp20_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_action_group_new ("StatusIconPopup");
	actions = _tmp0_;
	_tmp1_ = gtk_action_new ("About", NULL, NULL, GTK_STOCK_ABOUT);
	_g_object_unref0 (action);
	action = _tmp1_;
	_tmp2_ = action;
	_tmp3_ = self->priv->app;
	g_signal_connect_object (_tmp2_, "activate", (GCallback) _application_on_about_dialog_show_gtk_action_activate, _tmp3_, 0);
	_tmp4_ = actions;
	_tmp5_ = action;
	gtk_action_group_add_action (_tmp4_, _tmp5_);
	_tmp6_ = gtk_action_new ("Quit", NULL, NULL, GTK_STOCK_QUIT);
	_g_object_unref0 (action);
	action = _tmp6_;
	_tmp7_ = action;
	g_signal_connect_object (_tmp7_, "activate", (GCallback) _status_icon_if_on_quit_gtk_action_activate, self, 0);
	_tmp8_ = actions;
	_tmp9_ = action;
	gtk_action_group_add_action (_tmp8_, _tmp9_);
	_tmp10_ = gtk_ui_manager_new ();
	ui = _tmp10_;
	_tmp11_ = ui;
	_tmp12_ = actions;
	gtk_ui_manager_insert_action_group (_tmp11_, _tmp12_, 0);
	{
		GtkUIManager* _tmp13_;
		_tmp13_ = ui;
		gtk_ui_manager_add_ui_from_string (_tmp13_, ui_info, (gssize) (-1), &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch2_g_error;
		}
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError* e = NULL;
		FILE* _tmp14_;
		GError* _tmp15_;
		const gchar* _tmp16_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp14_ = stderr;
		_tmp15_ = e;
		_tmp16_ = _tmp15_->message;
		fprintf (_tmp14_, "Error: %s\n", _tmp16_);
		_g_error_free0 (e);
		_g_object_unref0 (ui);
		_g_object_unref0 (action);
		_g_object_unref0 (actions);
		return;
	}
	__finally2:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (ui);
		_g_object_unref0 (action);
		_g_object_unref0 (actions);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp17_ = ui;
	_tmp18_ = gtk_ui_manager_get_widget (_tmp17_, "/Popup");
	_tmp19_ = _g_object_ref0 (GTK_IS_MENU (_tmp18_) ? ((GtkMenu*) _tmp18_) : NULL);
	_g_object_unref0 (self->priv->menu);
	self->priv->menu = _tmp19_;
	_tmp20_ = self->priv->statusicon;
	g_signal_connect_object (_tmp20_, "popup-menu", (GCallback) _status_icon_if_on_popup_menu_gtk_status_icon_popup_menu, self, 0);
	_g_object_unref0 (ui);
	_g_object_unref0 (action);
	_g_object_unref0 (actions);
	return;
}


static gchar* status_icon_if_make_tooltip (StatusIconIF* self) {
	gchar* result = NULL;
	gdouble rx_av = 0.0;
	gdouble tx_av = 0.0;
	gdouble _tmp0_;
	IFace* _tmp1_;
	GQueue* _tmp2_;
	gconstpointer _tmp3_ = NULL;
	ByteStat* _tmp4_;
	ByteStat* last_stat;
	IFace* _tmp5_;
	GQueue* _tmp6_;
	gconstpointer _tmp7_ = NULL;
	ByteStat* _tmp8_;
	ByteStat* first_stat;
	IFace* _tmp9_;
	GQueue* _tmp10_;
	guint _tmp11_;
	ByteStat* _tmp28_;
	gdouble _tmp29_;
	gchar* _tmp30_ = NULL;
	gchar* rx_now;
	ByteStat* _tmp31_;
	gdouble _tmp32_;
	gchar* _tmp33_ = NULL;
	gchar* tx_now;
	gdouble _tmp34_;
	gchar* _tmp35_ = NULL;
	gchar* rx_av_text;
	gdouble _tmp36_;
	gchar* _tmp37_ = NULL;
	gchar* tx_av_text;
	IFace* _tmp38_;
	const gchar* _tmp39_;
	gchar* _tmp40_ = NULL;
	gchar* txt;
	g_return_val_if_fail (self != NULL, NULL);
	tx_av = 0.0;
	_tmp0_ = tx_av;
	rx_av = _tmp0_;
	_tmp1_ = self->iface;
	_tmp2_ = _tmp1_->flow_queue;
	_tmp3_ = g_queue_peek_tail (_tmp2_);
	_tmp4_ = _byte_stat_dup0 ((ByteStat*) _tmp3_);
	last_stat = _tmp4_;
	_tmp5_ = self->iface;
	_tmp6_ = _tmp5_->flow_queue;
	_tmp7_ = g_queue_peek_head (_tmp6_);
	_tmp8_ = _byte_stat_dup0 ((ByteStat*) _tmp7_);
	first_stat = _tmp8_;
	_tmp9_ = self->iface;
	_tmp10_ = _tmp9_->flow_queue;
	_tmp11_ = _tmp10_->length;
	if (_tmp11_ > ((guint) 1)) {
		ByteStat* _tmp12_;
		guint64 _tmp13_;
		ByteStat* _tmp14_;
		guint64 _tmp15_;
		ByteStat* _tmp16_;
		gdouble _tmp17_;
		ByteStat* _tmp18_;
		gdouble _tmp19_;
		ByteStat* _tmp20_;
		guint64 _tmp21_;
		ByteStat* _tmp22_;
		guint64 _tmp23_;
		ByteStat* _tmp24_;
		gdouble _tmp25_;
		ByteStat* _tmp26_;
		gdouble _tmp27_;
		_tmp12_ = last_stat;
		_tmp13_ = (*_tmp12_).rx_total;
		_tmp14_ = first_stat;
		_tmp15_ = (*_tmp14_).rx_total;
		_tmp16_ = last_stat;
		_tmp17_ = (*_tmp16_).time_stamp;
		_tmp18_ = first_stat;
		_tmp19_ = (*_tmp18_).time_stamp;
		rx_av = (_tmp13_ - _tmp15_) / (_tmp17_ - _tmp19_);
		_tmp20_ = last_stat;
		_tmp21_ = (*_tmp20_).tx_total;
		_tmp22_ = first_stat;
		_tmp23_ = (*_tmp22_).tx_total;
		_tmp24_ = last_stat;
		_tmp25_ = (*_tmp24_).time_stamp;
		_tmp26_ = first_stat;
		_tmp27_ = (*_tmp26_).time_stamp;
		tx_av = (_tmp21_ - _tmp23_) / (_tmp25_ - _tmp27_);
	}
	_tmp28_ = last_stat;
	_tmp29_ = (*_tmp28_).rx_speed;
	_tmp30_ = humanize_number (_tmp29_, 1024.0f, "B");
	rx_now = _tmp30_;
	_tmp31_ = last_stat;
	_tmp32_ = (*_tmp31_).tx_speed;
	_tmp33_ = humanize_number (_tmp32_, 1024.0f, "B");
	tx_now = _tmp33_;
	_tmp34_ = rx_av;
	_tmp35_ = humanize_number (_tmp34_, 1024.0f, "B");
	rx_av_text = _tmp35_;
	_tmp36_ = tx_av;
	_tmp37_ = humanize_number (_tmp36_, 1024.0f, "B");
	tx_av_text = _tmp37_;
	_tmp38_ = self->iface;
	_tmp39_ = _tmp38_->iface_id;
	_tmp40_ = g_strdup_printf ("Interface: %s\nIn/Out(current): %s/%s\nIn/Out(average): %s/%s", _tmp39_, rx_now, tx_now, rx_av_text, tx_av_text);
	txt = _tmp40_;
	result = txt;
	_g_free0 (tx_av_text);
	_g_free0 (rx_av_text);
	_g_free0 (tx_now);
	_g_free0 (rx_now);
	_byte_stat_free0 (first_stat);
	_byte_stat_free0 (last_stat);
	return result;
}


static gdouble status_icon_if_max_total_speed (StatusIconIF* self, GQueue* somed) {
	gdouble result = 0.0;
	gdouble _tmp0_;
	gdouble a;
	g_return_val_if_fail (self != NULL, 0.0);
	g_return_val_if_fail (somed != NULL, 0.0);
	_tmp0_ = DBL_MIN;
	a = _tmp0_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_;
				gint _tmp4_;
				GQueue* _tmp5_;
				guint _tmp6_;
				GQueue* _tmp7_;
				gint _tmp8_;
				gconstpointer _tmp9_ = NULL;
				ByteStat* _tmp10_;
				ByteStat* b;
				ByteStat* _tmp11_;
				gdouble _tmp12_;
				gdouble _tmp13_;
				_tmp2_ = _tmp1_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp4_ = i;
				_tmp5_ = somed;
				_tmp6_ = _tmp5_->length;
				if (!(((guint) _tmp4_) < _tmp6_)) {
					break;
				}
				_tmp7_ = somed;
				_tmp8_ = i;
				_tmp9_ = g_queue_peek_nth (_tmp7_, (guint) _tmp8_);
				_tmp10_ = _byte_stat_dup0 ((ByteStat*) _tmp9_);
				b = _tmp10_;
				_tmp11_ = b;
				_tmp12_ = (*_tmp11_).total_speed;
				_tmp13_ = a;
				if (_tmp12_ > _tmp13_) {
					ByteStat* _tmp14_;
					gdouble _tmp15_;
					_tmp14_ = b;
					_tmp15_ = (*_tmp14_).total_speed;
					a = _tmp15_;
				}
				_byte_stat_free0 (b);
			}
		}
	}
	result = a;
	return result;
}


gboolean status_icon_if_update_scale (StatusIconIF* self) {
	gboolean result = FALSE;
	cairo_surface_t* _tmp0_;
	gint _tmp1_ = 0;
	gint height;
	IFace* _tmp2_;
	GQueue* _tmp3_;
	gdouble _tmp4_ = 0.0;
	gdouble total;
	gfloat _tmp5_;
	gfloat port;
	gdouble _tmp6_;
	gfloat _tmp7_;
	gdouble _tmp9_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->surface;
	_tmp1_ = cairo_image_surface_get_height (_tmp0_);
	height = _tmp1_;
	_tmp2_ = self->iface;
	_tmp3_ = _tmp2_->flow_queue;
	_tmp4_ = status_icon_if_max_total_speed (self, _tmp3_);
	total = _tmp4_;
	_tmp5_ = self->portion;
	port = _tmp5_;
	_tmp6_ = total;
	_tmp7_ = self->rate_low;
	if (_tmp6_ < ((gdouble) _tmp7_)) {
		gfloat _tmp8_;
		_tmp8_ = self->portion_low;
		port = _tmp8_;
	}
	_tmp9_ = total;
	if (_tmp9_ > fdelta) {
		gint _tmp10_;
		gfloat _tmp11_;
		gdouble _tmp12_;
		gdouble lscale;
		gboolean _tmp13_ = FALSE;
		gboolean _tmp14_ = FALSE;
		gdouble _tmp15_;
		gboolean _tmp23_;
		gboolean _tmp27_;
		_tmp10_ = height;
		_tmp11_ = port;
		_tmp12_ = total;
		lscale = (_tmp10_ * _tmp11_) / _tmp12_;
		_tmp15_ = self->priv->scale;
		if (_tmp15_ < (-fdelta)) {
			_tmp14_ = TRUE;
		} else {
			gboolean _tmp16_ = FALSE;
			gdouble _tmp17_;
			gboolean _tmp22_;
			_tmp17_ = self->priv->scale;
			if (_tmp17_ > fdelta) {
				gdouble _tmp18_;
				gdouble _tmp19_;
				gdouble _tmp20_ = 0.0;
				gdouble _tmp21_;
				_tmp18_ = self->priv->scale;
				_tmp19_ = lscale;
				_tmp20_ = fabs (_tmp18_ - _tmp19_);
				_tmp21_ = self->priv->scale;
				_tmp16_ = (_tmp20_ / _tmp21_) > 0.3;
			} else {
				_tmp16_ = FALSE;
			}
			_tmp22_ = _tmp16_;
			_tmp14_ = _tmp22_;
		}
		_tmp23_ = _tmp14_;
		if (_tmp23_) {
			_tmp13_ = TRUE;
		} else {
			gint _tmp24_;
			gdouble _tmp25_;
			gdouble _tmp26_;
			_tmp24_ = height;
			_tmp25_ = self->priv->scale;
			_tmp26_ = total;
			_tmp13_ = ((gdouble) _tmp24_) < (_tmp25_ * _tmp26_);
		}
		_tmp27_ = _tmp13_;
		if (_tmp27_) {
			gdouble _tmp28_;
			_tmp28_ = lscale;
			self->priv->scale = _tmp28_;
		}
	}
	result = TRUE;
	return result;
}


static gdouble* _vala_array_dup1 (gdouble* self, int length) {
	return g_memdup (self, length * sizeof (gdouble));
}


static gdouble* _vala_array_dup2 (gdouble* self, int length) {
	return g_memdup (self, length * sizeof (gdouble));
}


static void status_icon_if_get_speed (StatusIconIF* self, gdouble max_speed, StatusIconIFTransSpeed* result) {
	IFace* _tmp0_;
	GQueue* _tmp1_;
	guint _tmp2_;
	gdouble* _tmp3_ = NULL;
	gdouble* rx_list;
	gint rx_list_length1;
	gint _rx_list_size_;
	IFace* _tmp4_;
	GQueue* _tmp5_;
	guint _tmp6_;
	gdouble* _tmp7_ = NULL;
	gdouble* tx_list;
	gint tx_list_length1;
	gint _tx_list_size_;
	gdouble _tmp8_;
	gdouble lscale = 0.0;
	gdouble _tmp9_;
	gdouble* _tmp42_;
	gint _tmp42__length1;
	gdouble* _tmp43_;
	gint _tmp43__length1;
	gdouble* _tmp44_;
	gint _tmp44__length1;
	gdouble* _tmp45_;
	gint _tmp45__length1;
	StatusIconIFTransSpeed _tmp46_ = {0};
	StatusIconIFTransSpeed ret;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->iface;
	_tmp1_ = _tmp0_->flow_queue;
	_tmp2_ = _tmp1_->length;
	_tmp3_ = g_new0 (gdouble, _tmp2_);
	rx_list = _tmp3_;
	rx_list_length1 = _tmp2_;
	_rx_list_size_ = rx_list_length1;
	_tmp4_ = self->iface;
	_tmp5_ = _tmp4_->flow_queue;
	_tmp6_ = _tmp5_->length;
	_tmp7_ = g_new0 (gdouble, _tmp6_);
	tx_list = _tmp7_;
	tx_list_length1 = _tmp6_;
	_tx_list_size_ = tx_list_length1;
	_tmp8_ = self->priv->scale;
	if (_tmp8_ < (-fdelta)) {
		status_icon_if_update_scale (self);
	}
	_tmp9_ = self->priv->scale;
	if (_tmp9_ < (-fdelta)) {
		lscale = 1.0;
	} else {
		gdouble _tmp10_;
		_tmp10_ = self->priv->scale;
		lscale = _tmp10_;
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp11_;
			_tmp11_ = TRUE;
			while (TRUE) {
				gboolean _tmp12_;
				gint _tmp14_;
				IFace* _tmp15_;
				GQueue* _tmp16_;
				guint _tmp17_;
				IFace* _tmp18_;
				GQueue* _tmp19_;
				gint _tmp20_;
				gconstpointer _tmp21_ = NULL;
				ByteStat* _tmp22_;
				ByteStat* statn;
				ByteStat* _tmp23_;
				gdouble _tmp24_;
				gdouble _tmp25_;
				gdouble rspeed;
				ByteStat* _tmp26_;
				gdouble _tmp27_;
				gdouble _tmp28_;
				gdouble tspeed;
				gdouble _tmp29_;
				gdouble _tmp30_;
				gdouble _tmp31_;
				_tmp12_ = _tmp11_;
				if (!_tmp12_) {
					gint _tmp13_;
					_tmp13_ = i;
					i = _tmp13_ + 1;
				}
				_tmp11_ = FALSE;
				_tmp14_ = i;
				_tmp15_ = self->iface;
				_tmp16_ = _tmp15_->flow_queue;
				_tmp17_ = _tmp16_->length;
				if (!(((guint) _tmp14_) < _tmp17_)) {
					break;
				}
				_tmp18_ = self->iface;
				_tmp19_ = _tmp18_->flow_queue;
				_tmp20_ = i;
				_tmp21_ = g_queue_peek_nth (_tmp19_, (guint) _tmp20_);
				_tmp22_ = _byte_stat_dup0 ((ByteStat*) _tmp21_);
				statn = _tmp22_;
				_tmp23_ = statn;
				_tmp24_ = (*_tmp23_).rx_speed;
				_tmp25_ = lscale;
				rspeed = _tmp24_ * _tmp25_;
				_tmp26_ = statn;
				_tmp27_ = (*_tmp26_).tx_speed;
				_tmp28_ = lscale;
				tspeed = _tmp27_ * _tmp28_;
				_tmp29_ = rspeed;
				_tmp30_ = tspeed;
				_tmp31_ = max_speed;
				if ((_tmp29_ + _tmp30_) > _tmp31_) {
					gdouble _tmp32_;
					StatusIconIFTransSpeed _tmp33_ = {0};
					status_icon_if_update_scale (self);
					_tmp32_ = max_speed;
					status_icon_if_get_speed (self, _tmp32_, &_tmp33_);
					*result = _tmp33_;
					_byte_stat_free0 (statn);
					tx_list = (g_free (tx_list), NULL);
					rx_list = (g_free (rx_list), NULL);
					return;
				} else {
					gdouble* _tmp34_;
					gint _tmp34__length1;
					gint _tmp35_;
					gdouble _tmp36_;
					gdouble _tmp37_;
					gdouble* _tmp38_;
					gint _tmp38__length1;
					gint _tmp39_;
					gdouble _tmp40_;
					gdouble _tmp41_;
					_tmp34_ = rx_list;
					_tmp34__length1 = rx_list_length1;
					_tmp35_ = i;
					_tmp36_ = rspeed;
					_tmp34_[_tmp35_] = _tmp36_;
					_tmp37_ = _tmp34_[_tmp35_];
					_tmp38_ = tx_list;
					_tmp38__length1 = tx_list_length1;
					_tmp39_ = i;
					_tmp40_ = tspeed;
					_tmp38_[_tmp39_] = _tmp40_;
					_tmp41_ = _tmp38_[_tmp39_];
				}
				_byte_stat_free0 (statn);
			}
		}
	}
	_tmp42_ = rx_list;
	_tmp42__length1 = rx_list_length1;
	_tmp43_ = (_tmp42_ != NULL) ? _vala_array_dup1 (_tmp42_, _tmp42__length1) : ((gpointer) _tmp42_);
	_tmp43__length1 = _tmp42__length1;
	_tmp44_ = tx_list;
	_tmp44__length1 = tx_list_length1;
	_tmp45_ = (_tmp44_ != NULL) ? _vala_array_dup2 (_tmp44_, _tmp44__length1) : ((gpointer) _tmp44_);
	_tmp45__length1 = _tmp44__length1;
	memset (&_tmp46_, 0, sizeof (StatusIconIFTransSpeed));
	_tmp46_.rx_list = (g_free (_tmp46_.rx_list), NULL);
	_tmp46_.rx_list = _tmp43_;
	_tmp46_.rx_list_length1 = _tmp43__length1;
	_tmp46_._rx_list_size_ = _tmp46_.rx_list_length1;
	_tmp46_.tx_list = (g_free (_tmp46_.tx_list), NULL);
	_tmp46_.tx_list = _tmp45_;
	_tmp46_.tx_list_length1 = _tmp45__length1;
	_tmp46_._tx_list_size_ = _tmp46_.tx_list_length1;
	ret = _tmp46_;
	*result = ret;
	tx_list = (g_free (tx_list), NULL);
	rx_list = (g_free (rx_list), NULL);
	return;
}


static gdouble* _vala_array_dup3 (gdouble* self, int length) {
	return g_memdup (self, length * sizeof (gdouble));
}


static gdouble* _vala_array_dup4 (gdouble* self, int length) {
	return g_memdup (self, length * sizeof (gdouble));
}


gboolean status_icon_if_update (StatusIconIF* self) {
	gboolean result = FALSE;
	cairo_t* _tmp0_;
	IFace* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* tooltxt;
	GtkStatusIcon* _tmp3_;
	const gchar* _tmp4_;
	cairo_surface_t* _tmp5_;
	gint _tmp6_ = 0;
	gint graph_width;
	cairo_surface_t* _tmp7_;
	gint _tmp8_ = 0;
	gint graph_height;
	gint _tmp9_;
	StatusIconIFTransSpeed _tmp10_ = {0};
	StatusIconIFTransSpeed ls;
	StatusIconIFTransSpeed _tmp11_;
	gdouble* _tmp12_;
	gint _tmp12__length1;
	gdouble* _tmp13_;
	gint _tmp13__length1;
	gdouble* rx_list;
	gint rx_list_length1;
	gint _rx_list_size_;
	StatusIconIFTransSpeed _tmp14_;
	gdouble* _tmp15_;
	gint _tmp15__length1;
	gdouble* _tmp16_;
	gint _tmp16__length1;
	gdouble* tx_list;
	gint tx_list_length1;
	gint _tx_list_size_;
	gint _tmp17_;
	IFace* _tmp18_;
	guint _tmp19_;
	gfloat slow_width;
	IFace* _tmp20_;
	guint _tmp21_;
	gdouble* _tmp22_;
	gint _tmp22__length1;
	guint xoffset;
	cairo_t* _tmp23_;
	cairo_t* _tmp24_;
	cairo_t* _tmp25_;
	gfloat* _tmp26_;
	gint _tmp26__length1;
	gfloat _tmp27_;
	gfloat* _tmp28_;
	gint _tmp28__length1;
	gfloat _tmp29_;
	gfloat* _tmp30_;
	gint _tmp30__length1;
	gfloat _tmp31_;
	cairo_t* _tmp32_;
	cairo_t* _tmp49_;
	cairo_t* _tmp50_;
	gfloat* _tmp51_;
	gint _tmp51__length1;
	gfloat _tmp52_;
	gfloat* _tmp53_;
	gint _tmp53__length1;
	gfloat _tmp54_;
	gfloat* _tmp55_;
	gint _tmp55__length1;
	gfloat _tmp56_;
	cairo_t* _tmp57_;
	cairo_t* _tmp72_;
	cairo_t* _tmp73_;
	cairo_surface_t* _tmp74_;
	gint _tmp75_;
	gint _tmp76_;
	GdkPixbuf* _tmp77_ = NULL;
	GdkPixbuf* pixbuf;
	GtkStatusIcon* _tmp78_;
	GdkPixbuf* _tmp79_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->ctx;
	if (_tmp0_ == NULL) {
		result = TRUE;
		return result;
	}
	_tmp1_ = self->iface;
	iface_update (_tmp1_);
	_tmp2_ = status_icon_if_make_tooltip (self);
	tooltxt = _tmp2_;
	_tmp3_ = self->priv->statusicon;
	_tmp4_ = tooltxt;
	gtk_status_icon_set_tooltip_text (_tmp3_, _tmp4_);
	_tmp5_ = self->priv->surface;
	_tmp6_ = cairo_image_surface_get_width (_tmp5_);
	graph_width = _tmp6_;
	_tmp7_ = self->priv->surface;
	_tmp8_ = cairo_image_surface_get_height (_tmp7_);
	graph_height = _tmp8_;
	_tmp9_ = graph_height;
	status_icon_if_get_speed (self, (gdouble) _tmp9_, &_tmp10_);
	ls = _tmp10_;
	_tmp11_ = ls;
	_tmp12_ = _tmp11_.rx_list;
	_tmp12__length1 = _tmp11_.rx_list_length1;
	_tmp13_ = (_tmp12_ != NULL) ? _vala_array_dup3 (_tmp12_, _tmp12__length1) : ((gpointer) _tmp12_);
	_tmp13__length1 = _tmp12__length1;
	rx_list = _tmp13_;
	rx_list_length1 = _tmp13__length1;
	_rx_list_size_ = rx_list_length1;
	_tmp14_ = ls;
	_tmp15_ = _tmp14_.tx_list;
	_tmp15__length1 = _tmp14_.tx_list_length1;
	_tmp16_ = (_tmp15_ != NULL) ? _vala_array_dup4 (_tmp15_, _tmp15__length1) : ((gpointer) _tmp15_);
	_tmp16__length1 = _tmp15__length1;
	tx_list = _tmp16_;
	tx_list_length1 = _tmp16__length1;
	_tx_list_size_ = tx_list_length1;
	_tmp17_ = graph_width;
	_tmp18_ = self->iface;
	_tmp19_ = _tmp18_->maxlen;
	slow_width = ((gfloat) _tmp17_) / _tmp19_;
	_tmp20_ = self->iface;
	_tmp21_ = _tmp20_->maxlen;
	_tmp22_ = rx_list;
	_tmp22__length1 = rx_list_length1;
	xoffset = _tmp21_ - _tmp22__length1;
	_tmp23_ = self->priv->ctx;
	cairo_paint (_tmp23_);
	_tmp24_ = self->priv->ctx;
	cairo_save (_tmp24_);
	_tmp25_ = self->priv->ctx;
	_tmp26_ = self->rx_color;
	_tmp26__length1 = self->rx_color_length1;
	_tmp27_ = _tmp26_[0];
	_tmp28_ = self->rx_color;
	_tmp28__length1 = self->rx_color_length1;
	_tmp29_ = _tmp28_[1];
	_tmp30_ = self->rx_color;
	_tmp30__length1 = self->rx_color_length1;
	_tmp31_ = _tmp30_[2];
	cairo_set_source_rgb (_tmp25_, (gdouble) _tmp27_, (gdouble) _tmp29_, (gdouble) _tmp31_);
	_tmp32_ = self->priv->ctx;
	cairo_new_path (_tmp32_);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp33_;
			_tmp33_ = TRUE;
			while (TRUE) {
				gboolean _tmp34_;
				gint _tmp36_;
				gdouble* _tmp37_;
				gint _tmp37__length1;
				gdouble* _tmp38_;
				gint _tmp38__length1;
				gint _tmp39_;
				gdouble _tmp40_;
				gdouble speed;
				cairo_t* _tmp41_;
				gfloat _tmp42_;
				gint _tmp43_;
				guint _tmp44_;
				gint _tmp45_;
				gdouble _tmp46_;
				gfloat _tmp47_;
				gdouble _tmp48_;
				_tmp34_ = _tmp33_;
				if (!_tmp34_) {
					gint _tmp35_;
					_tmp35_ = i;
					i = _tmp35_ + 1;
				}
				_tmp33_ = FALSE;
				_tmp36_ = i;
				_tmp37_ = rx_list;
				_tmp37__length1 = rx_list_length1;
				if (!(_tmp36_ < _tmp37__length1)) {
					break;
				}
				_tmp38_ = rx_list;
				_tmp38__length1 = rx_list_length1;
				_tmp39_ = i;
				_tmp40_ = _tmp38_[_tmp39_];
				speed = _tmp40_;
				_tmp41_ = self->priv->ctx;
				_tmp42_ = slow_width;
				_tmp43_ = i;
				_tmp44_ = xoffset;
				_tmp45_ = graph_height;
				_tmp46_ = speed;
				_tmp47_ = slow_width;
				_tmp48_ = speed;
				cairo_rectangle (_tmp41_, (gdouble) (_tmp42_ * (_tmp43_ + _tmp44_)), _tmp45_ - _tmp46_, (gdouble) _tmp47_, _tmp48_);
			}
		}
	}
	_tmp49_ = self->priv->ctx;
	cairo_fill (_tmp49_);
	_tmp50_ = self->priv->ctx;
	_tmp51_ = self->tx_color;
	_tmp51__length1 = self->tx_color_length1;
	_tmp52_ = _tmp51_[0];
	_tmp53_ = self->tx_color;
	_tmp53__length1 = self->tx_color_length1;
	_tmp54_ = _tmp53_[1];
	_tmp55_ = self->tx_color;
	_tmp55__length1 = self->tx_color_length1;
	_tmp56_ = _tmp55_[2];
	cairo_set_source_rgb (_tmp50_, (gdouble) _tmp52_, (gdouble) _tmp54_, (gdouble) _tmp56_);
	_tmp57_ = self->priv->ctx;
	cairo_new_path (_tmp57_);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp58_;
			_tmp58_ = TRUE;
			while (TRUE) {
				gboolean _tmp59_;
				gint _tmp61_;
				gdouble* _tmp62_;
				gint _tmp62__length1;
				gdouble* _tmp63_;
				gint _tmp63__length1;
				gint _tmp64_;
				gdouble _tmp65_;
				gdouble speed;
				cairo_t* _tmp66_;
				gfloat _tmp67_;
				gint _tmp68_;
				guint _tmp69_;
				gfloat _tmp70_;
				gdouble _tmp71_;
				_tmp59_ = _tmp58_;
				if (!_tmp59_) {
					gint _tmp60_;
					_tmp60_ = i;
					i = _tmp60_ + 1;
				}
				_tmp58_ = FALSE;
				_tmp61_ = i;
				_tmp62_ = tx_list;
				_tmp62__length1 = tx_list_length1;
				if (!(_tmp61_ < _tmp62__length1)) {
					break;
				}
				_tmp63_ = tx_list;
				_tmp63__length1 = tx_list_length1;
				_tmp64_ = i;
				_tmp65_ = _tmp63_[_tmp64_];
				speed = _tmp65_;
				_tmp66_ = self->priv->ctx;
				_tmp67_ = slow_width;
				_tmp68_ = i;
				_tmp69_ = xoffset;
				_tmp70_ = slow_width;
				_tmp71_ = speed;
				cairo_rectangle (_tmp66_, (gdouble) (_tmp67_ * (_tmp68_ + _tmp69_)), (gdouble) 0, (gdouble) _tmp70_, _tmp71_);
			}
		}
	}
	_tmp72_ = self->priv->ctx;
	cairo_fill (_tmp72_);
	_tmp73_ = self->priv->ctx;
	cairo_restore (_tmp73_);
	_tmp74_ = self->priv->surface;
	_tmp75_ = graph_width;
	_tmp76_ = graph_height;
	_tmp77_ = gdk_pixbuf_get_from_surface (_tmp74_, 0, 0, _tmp75_, _tmp76_);
	pixbuf = _tmp77_;
	_tmp78_ = self->priv->statusicon;
	_tmp79_ = pixbuf;
	gtk_status_icon_set_from_pixbuf (_tmp78_, _tmp79_);
	result = TRUE;
	_g_object_unref0 (pixbuf);
	tx_list = (g_free (tx_list), NULL);
	rx_list = (g_free (rx_list), NULL);
	status_icon_if_trans_speed_destroy (&ls);
	_g_free0 (tooltxt);
	return result;
}


static gboolean _status_icon_if_update_gsource_func (gpointer self) {
	gboolean result;
	result = status_icon_if_update (self);
	return result;
}


static gboolean _status_icon_if_update_scale_gsource_func (gpointer self) {
	gboolean result;
	result = status_icon_if_update_scale (self);
	return result;
}


void status_icon_if_start_timers (StatusIconIF* self) {
	guint _tmp0_;
	guint _tmp1_ = 0U;
	guint _tmp2_;
	guint _tmp3_ = 0U;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->update_timeout;
	_tmp1_ = g_timeout_add_full (G_PRIORITY_DEFAULT, _tmp0_, _status_icon_if_update_gsource_func, g_object_ref (self), g_object_unref);
	self->priv->update_id = _tmp1_;
	_tmp2_ = self->update_scale_timeout;
	_tmp3_ = g_timeout_add_full (G_PRIORITY_DEFAULT, _tmp2_, _status_icon_if_update_scale_gsource_func, g_object_ref (self), g_object_unref);
	self->priv->update_scale_id = _tmp3_;
}


void status_icon_if_on_quit (StatusIconIF* self, GtkAction* act) {
	Application* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (act != NULL);
	_tmp0_ = self->priv->app;
	application_quit (_tmp0_);
}


void status_icon_if_on_destroy (StatusIconIF* self) {
	guint _tmp0_;
	guint _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->update_id;
	g_source_remove (_tmp0_);
	_tmp1_ = self->priv->update_scale_id;
	g_source_remove (_tmp1_);
}


static gdouble* _vala_array_dup5 (gdouble* self, int length) {
	return g_memdup (self, length * sizeof (gdouble));
}


static gdouble* _vala_array_dup6 (gdouble* self, int length) {
	return g_memdup (self, length * sizeof (gdouble));
}


static void status_icon_if_trans_speed_copy (const StatusIconIFTransSpeed* self, StatusIconIFTransSpeed* dest) {
	gdouble* _tmp0_;
	gint _tmp0__length1;
	gdouble* _tmp1_;
	gint _tmp1__length1;
	gdouble* _tmp2_;
	gint _tmp2__length1;
	gdouble* _tmp3_;
	gint _tmp3__length1;
	_tmp0_ = (*self).rx_list;
	_tmp0__length1 = (*self).rx_list_length1;
	_tmp1_ = (_tmp0_ != NULL) ? _vala_array_dup5 (_tmp0_, _tmp0__length1) : ((gpointer) _tmp0_);
	_tmp1__length1 = _tmp0__length1;
	(*dest).rx_list = (g_free ((*dest).rx_list), NULL);
	(*dest).rx_list = _tmp1_;
	(*dest).rx_list_length1 = _tmp1__length1;
	(*dest)._rx_list_size_ = (*dest).rx_list_length1;
	_tmp2_ = (*self).tx_list;
	_tmp2__length1 = (*self).tx_list_length1;
	_tmp3_ = (_tmp2_ != NULL) ? _vala_array_dup6 (_tmp2_, _tmp2__length1) : ((gpointer) _tmp2_);
	_tmp3__length1 = _tmp2__length1;
	(*dest).tx_list = (g_free ((*dest).tx_list), NULL);
	(*dest).tx_list = _tmp3_;
	(*dest).tx_list_length1 = _tmp3__length1;
	(*dest)._tx_list_size_ = (*dest).tx_list_length1;
}


static void status_icon_if_trans_speed_destroy (StatusIconIFTransSpeed* self) {
	(*self).rx_list = (g_free ((*self).rx_list), NULL);
	(*self).tx_list = (g_free ((*self).tx_list), NULL);
}


static StatusIconIFTransSpeed* status_icon_if_trans_speed_dup (const StatusIconIFTransSpeed* self) {
	StatusIconIFTransSpeed* dup;
	dup = g_new0 (StatusIconIFTransSpeed, 1);
	status_icon_if_trans_speed_copy (self, dup);
	return dup;
}


static void status_icon_if_trans_speed_free (StatusIconIFTransSpeed* self) {
	status_icon_if_trans_speed_destroy (self);
	g_free (self);
}


static GType status_icon_if_trans_speed_get_type (void) {
	static volatile gsize status_icon_if_trans_speed_type_id__volatile = 0;
	if (g_once_init_enter (&status_icon_if_trans_speed_type_id__volatile)) {
		GType status_icon_if_trans_speed_type_id;
		status_icon_if_trans_speed_type_id = g_boxed_type_register_static ("StatusIconIFTransSpeed", (GBoxedCopyFunc) status_icon_if_trans_speed_dup, (GBoxedFreeFunc) status_icon_if_trans_speed_free);
		g_once_init_leave (&status_icon_if_trans_speed_type_id__volatile, status_icon_if_trans_speed_type_id);
	}
	return status_icon_if_trans_speed_type_id__volatile;
}


static void status_icon_if_class_init (StatusIconIFClass * klass) {
	status_icon_if_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (StatusIconIFPrivate));
	G_OBJECT_CLASS (klass)->finalize = status_icon_if_finalize;
}


static void status_icon_if_instance_init (StatusIconIF * self) {
	gfloat* _tmp0_ = NULL;
	gfloat* _tmp1_ = NULL;
	self->priv = STATUS_ICON_IF_GET_PRIVATE (self);
	self->priv->ctx = NULL;
	self->priv->scale = -1.0;
	self->priv->margin = 1;
	_tmp0_ = g_new0 (gfloat, 3);
	_tmp0_[0] = 0.0f;
	_tmp0_[1] = 1.0f;
	_tmp0_[2] = 0.0f;
	self->rx_color = _tmp0_;
	self->rx_color_length1 = 3;
	_tmp1_ = g_new0 (gfloat, 3);
	_tmp1_[0] = 1.0f;
	_tmp1_[1] = 1.0f;
	_tmp1_[2] = 0.0f;
	self->tx_color = _tmp1_;
	self->tx_color_length1 = 3;
	self->portion = 0.8f;
	self->portion_low = 0.3f;
	self->rate_low = 1024.0f;
	self->update_timeout = (guint) 1000;
}


static void status_icon_if_finalize (GObject* obj) {
	StatusIconIF * self;
	self = STATUS_ICON_IF (obj);
	_g_object_unref0 (self->priv->app);
	_cairo_destroy0 (self->priv->ctx);
	_cairo_surface_destroy0 (self->priv->surface);
	_g_object_unref0 (self->priv->statusicon);
	_g_object_unref0 (self->priv->menu);
	_g_object_unref0 (self->iface);
	self->rx_color = (g_free (self->rx_color), NULL);
	self->tx_color = (g_free (self->tx_color), NULL);
	G_OBJECT_CLASS (status_icon_if_parent_class)->finalize (obj);
}


GType status_icon_if_get_type (void) {
	static volatile gsize status_icon_if_type_id__volatile = 0;
	if (g_once_init_enter (&status_icon_if_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (StatusIconIFClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) status_icon_if_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (StatusIconIF), 0, (GInstanceInitFunc) status_icon_if_instance_init, NULL };
		GType status_icon_if_type_id;
		status_icon_if_type_id = g_type_register_static (G_TYPE_OBJECT, "StatusIconIF", &g_define_type_info, 0);
		g_once_init_leave (&status_icon_if_type_id__volatile, status_icon_if_type_id);
	}
	return status_icon_if_type_id__volatile;
}


static gint __lambda2_ (Application* self, const gchar* a, const gchar* b) {
	gint result = 0;
	GCompareFunc _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	gint _tmp3_ = 0;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp0_ = g_strcmp0;
	_tmp1_ = a;
	_tmp2_ = b;
	_tmp3_ = _tmp0_ (_tmp1_, _tmp2_);
	result = _tmp3_;
	return result;
}


static gint ___lambda2__gcompare_data_func (gconstpointer a, gconstpointer b, gpointer self) {
	gint result;
	result = __lambda2_ (self, a, b);
	return result;
}


static Application* application_construct (GType object_type) {
	Application * self = NULL;
	GDestroyNotify _tmp0_;
	GDestroyNotify _tmp1_;
	GTree* _tmp2_;
	self = (Application*) g_object_new (object_type, NULL);
	_tmp0_ = g_free;
	_tmp1_ = g_object_unref;
	_tmp2_ = g_tree_new_full (___lambda2__gcompare_data_func, self, _tmp0_, _tmp1_);
	_g_tree_destroy0 (self->priv->iface_map);
	self->priv->iface_map = _tmp2_;
	return self;
}


static Application* application_new (void) {
	return application_construct (TYPE_APPLICATION);
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		Application * self;
		self = _data1_->self;
		_data1_->key2remove = (_vala_array_free (_data1_->key2remove, _data1_->key2remove_length1, (GDestroyNotify) g_free), NULL);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static gint __lambda3_ (Block1Data* _data1_, void* k, void* v) {
	Application * self;
	gint result = 0;
	void* _tmp0_;
	StatusIconIF* _tmp1_;
	StatusIconIF* v1;
	StatusIconIF* _tmp2_;
	IFace* _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp5_;
	self = _data1_->self;
	_tmp0_ = v;
	_tmp1_ = _g_object_ref0 (IS_STATUS_ICON_IF (_tmp0_) ? ((StatusIconIF*) _tmp0_) : NULL);
	v1 = _tmp1_;
	_tmp2_ = v1;
	_tmp3_ = _tmp2_->iface;
	_tmp4_ = iface_get_isup (_tmp3_);
	_tmp5_ = _tmp4_;
	if (!_tmp5_) {
		gchar** _tmp6_;
		gint _tmp6__length1;
		void* _tmp7_;
		gchar* _tmp8_;
		_tmp6_ = _data1_->key2remove;
		_tmp6__length1 = _data1_->key2remove_length1;
		_tmp7_ = k;
		_tmp8_ = g_strdup ((const gchar*) _tmp7_);
		_vala_array_add1 (&_data1_->key2remove, &_data1_->key2remove_length1, &_data1_->_key2remove_size_, _tmp8_);
	}
	result = 0;
	_g_object_unref0 (v1);
	return result;
}


static gint ___lambda3__gtraverse_func (void* key, void* value, gpointer self) {
	gint result;
	result = __lambda3_ (self, key, value);
	return result;
}


static gboolean application_update_iface (Application* self) {
	gboolean result = FALSE;
	Block1Data* _data1_;
	gchar** _tmp33_ = NULL;
	GTree* _tmp34_;
	gchar** _tmp35_;
	gint _tmp35__length1;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	{
		GFile* _tmp0_ = NULL;
		GFile* root;
		GFile* _tmp1_;
		GFileEnumerator* _tmp2_ = NULL;
		GFileEnumerator* root_enum;
		GFileInfo* file_info = NULL;
		_tmp0_ = g_file_new_for_path (SYS_NET_PATH);
		root = _tmp0_;
		_tmp1_ = root;
		_tmp2_ = g_file_enumerate_children (_tmp1_, G_FILE_ATTRIBUTE_STANDARD_NAME, 0, NULL, &_inner_error_);
		root_enum = _tmp2_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (root);
			goto __catch3_g_error;
		}
		while (TRUE) {
			GFileEnumerator* _tmp3_;
			GFileInfo* _tmp4_ = NULL;
			GFileInfo* _tmp5_;
			GFileInfo* _tmp6_;
			GFileInfo* _tmp7_;
			const gchar* _tmp8_ = NULL;
			gchar* _tmp9_;
			gchar* fid;
			gboolean _tmp10_ = FALSE;
			const gchar* _tmp11_;
			gboolean _tmp15_;
			_tmp3_ = root_enum;
			_tmp4_ = g_file_enumerator_next_file (_tmp3_, NULL, &_inner_error_);
			_tmp5_ = _tmp4_;
			if (_inner_error_ != NULL) {
				_g_object_unref0 (file_info);
				_g_object_unref0 (root_enum);
				_g_object_unref0 (root);
				goto __catch3_g_error;
			}
			_g_object_unref0 (file_info);
			file_info = _tmp5_;
			_tmp6_ = file_info;
			if (!(_tmp6_ != NULL)) {
				break;
			}
			_tmp7_ = file_info;
			_tmp8_ = g_file_info_get_name (_tmp7_);
			_tmp9_ = g_strdup (_tmp8_);
			fid = _tmp9_;
			_tmp11_ = fid;
			if (g_strcmp0 (_tmp11_, "lo") != 0) {
				GTree* _tmp12_;
				const gchar* _tmp13_;
				gconstpointer _tmp14_ = NULL;
				_tmp12_ = self->priv->iface_map;
				_tmp13_ = fid;
				_tmp14_ = g_tree_lookup (_tmp12_, _tmp13_);
				_tmp10_ = ((StatusIconIF*) _tmp14_) == NULL;
			} else {
				_tmp10_ = FALSE;
			}
			_tmp15_ = _tmp10_;
			if (_tmp15_) {
				const gchar* _tmp16_;
				IFace* _tmp17_;
				IFace* iface;
				IFace* _tmp18_;
				gboolean _tmp19_;
				gboolean _tmp20_;
				_tmp16_ = fid;
				_tmp17_ = iface_new (_tmp16_);
				iface = _tmp17_;
				_tmp18_ = iface;
				_tmp19_ = iface_get_isup (_tmp18_);
				_tmp20_ = _tmp19_;
				if (_tmp20_) {
					IFace* _tmp21_;
					StatusIconIF* _tmp22_;
					StatusIconIF* v;
					StatusIconIF* _tmp23_;
					StatusIconIF* _tmp24_;
					GTree* _tmp25_;
					const gchar* _tmp26_;
					gchar* _tmp27_;
					StatusIconIF* _tmp28_;
					StatusIconIF* _tmp29_;
					_tmp21_ = iface;
					_tmp22_ = status_icon_if_new (self, _tmp21_);
					v = _tmp22_;
					_tmp23_ = v;
					status_icon_if_start_timers (_tmp23_);
					_tmp24_ = v;
					status_icon_if_update (_tmp24_);
					_tmp25_ = self->priv->iface_map;
					_tmp26_ = fid;
					_tmp27_ = g_strdup (_tmp26_);
					_tmp28_ = v;
					_tmp29_ = _g_object_ref0 (_tmp28_);
					g_tree_insert (_tmp25_, _tmp27_, _tmp29_);
					_g_object_unref0 (v);
				}
				_g_object_unref0 (iface);
			}
			_g_free0 (fid);
		}
		_g_object_unref0 (file_info);
		_g_object_unref0 (root_enum);
		_g_object_unref0 (root);
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* e = NULL;
		FILE* _tmp30_;
		GError* _tmp31_;
		const gchar* _tmp32_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp30_ = stderr;
		_tmp31_ = e;
		_tmp32_ = _tmp31_->message;
		fprintf (_tmp30_, "Error: %s\n", _tmp32_);
		_g_error_free0 (e);
	}
	__finally3:
	if (_inner_error_ != NULL) {
		block1_data_unref (_data1_);
		_data1_ = NULL;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	_tmp33_ = g_new0 (gchar*, 0 + 1);
	_data1_->key2remove = _tmp33_;
	_data1_->key2remove_length1 = 0;
	_data1_->_key2remove_size_ = _data1_->key2remove_length1;
	_tmp34_ = self->priv->iface_map;
	g_tree_foreach (_tmp34_, ___lambda3__gtraverse_func, _data1_);
	_tmp35_ = _data1_->key2remove;
	_tmp35__length1 = _data1_->key2remove_length1;
	{
		gchar** k_collection = NULL;
		gint k_collection_length1 = 0;
		gint _k_collection_size_ = 0;
		gint k_it = 0;
		k_collection = _tmp35_;
		k_collection_length1 = _tmp35__length1;
		for (k_it = 0; k_it < _tmp35__length1; k_it = k_it + 1) {
			gchar* _tmp36_;
			gchar* k = NULL;
			_tmp36_ = g_strdup (k_collection[k_it]);
			k = _tmp36_;
			{
				GTree* _tmp37_;
				const gchar* _tmp38_;
				gconstpointer _tmp39_ = NULL;
				GTree* _tmp40_;
				const gchar* _tmp41_;
				_tmp37_ = self->priv->iface_map;
				_tmp38_ = k;
				_tmp39_ = g_tree_lookup (_tmp37_, _tmp38_);
				status_icon_if_on_destroy ((StatusIconIF*) _tmp39_);
				_tmp40_ = self->priv->iface_map;
				_tmp41_ = k;
				g_tree_remove (_tmp40_, _tmp41_);
				_g_free0 (k);
			}
		}
	}
	result = TRUE;
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return result;
}


static void __lambda4_ (Application* self, GtkDialog* a, gint b) {
	GtkDialog* _tmp0_;
	gulong _tmp1_;
	GtkDialog* _tmp2_;
	g_return_if_fail (a != NULL);
	_tmp0_ = a;
	_tmp1_ = self->priv->about_response_id;
	g_signal_handler_disconnect ((GObject*) _tmp0_, _tmp1_);
	_tmp2_ = a;
	gtk_widget_destroy ((GtkWidget*) _tmp2_);
}


static void ___lambda4__gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self) {
	__lambda4_ (self, _sender, response_id);
}


void application_on_about_dialog_show (Application* self, GtkAction* act) {
	GtkAboutDialog* _tmp0_;
	GtkAboutDialog* _tmp1_;
	GtkAboutDialog* ad;
	gulong _tmp2_ = 0UL;
	gchar* _tmp3_;
	gchar** _tmp4_ = NULL;
	gchar** authors;
	gint authors_length1;
	gint _authors_size_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (act != NULL);
	_tmp0_ = (GtkAboutDialog*) gtk_about_dialog_new ();
	_tmp1_ = g_object_ref_sink (_tmp0_);
	ad = _tmp1_;
	_tmp2_ = g_signal_connect_object ((GtkDialog*) ad, "response", (GCallback) ___lambda4__gtk_dialog_response, self, 0);
	self->priv->about_response_id = _tmp2_;
	gtk_about_dialog_set_program_name (ad, PACKAGE_NAME);
	gtk_about_dialog_set_version (ad, HGVERSION);
	gtk_about_dialog_set_copyright (ad, "Mozbugbox 2011-2013");
	gtk_about_dialog_set_license_type (ad, GTK_LICENSE_GPL_3_0);
	gtk_about_dialog_set_website (ad, PACKAGE_URL);
	gtk_about_dialog_set_website_label (ad, "Byte On Panel Wiki");
	_tmp3_ = g_strdup ("Mozbugbox");
	_tmp4_ = g_new0 (gchar*, 1 + 1);
	_tmp4_[0] = _tmp3_;
	authors = _tmp4_;
	authors_length1 = 1;
	_authors_size_ = authors_length1;
	gtk_about_dialog_set_authors (ad, authors);
	gtk_window_present ((GtkWindow*) ad);
	authors = (_vala_array_free (authors, authors_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (ad);
}


static gboolean _application_update_iface_gsource_func (gpointer self) {
	gboolean result;
	result = application_update_iface (self);
	return result;
}


void application_start (Application* self) {
	guint _tmp0_;
	g_return_if_fail (self != NULL);
	application_update_iface (self);
	_tmp0_ = self->priv->iface_update_timeout;
	g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, _tmp0_, _application_update_iface_gsource_func, g_object_ref (self), g_object_unref);
	gtk_main ();
}


void application_quit (Application* self) {
	g_return_if_fail (self != NULL);
	gtk_main_quit ();
}


gint application_main (gchar** args, int args_length1) {
	gint result = 0;
	Application* _tmp0_;
	Application* app;
	gtk_init (&args_length1, &args);
	_tmp0_ = application_new ();
	app = _tmp0_;
	application_start (app);
	result = 0;
	_g_object_unref0 (app);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return application_main (argv, argc);
}


static void application_class_init (ApplicationClass * klass) {
	application_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ApplicationPrivate));
	G_OBJECT_CLASS (klass)->finalize = application_finalize;
}


static void application_instance_init (Application * self) {
	self->priv = APPLICATION_GET_PRIVATE (self);
	self->priv->iface_update_timeout = (guint) 5;
}


static void application_finalize (GObject* obj) {
	Application * self;
	self = APPLICATION (obj);
	_g_tree_destroy0 (self->priv->iface_map);
	G_OBJECT_CLASS (application_parent_class)->finalize (obj);
}


GType application_get_type (void) {
	static volatile gsize application_type_id__volatile = 0;
	if (g_once_init_enter (&application_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ApplicationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) application_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Application), 0, (GInstanceInitFunc) application_instance_init, NULL };
		GType application_type_id;
		application_type_id = g_type_register_static (G_TYPE_OBJECT, "Application", &g_define_type_info, 0);
		g_once_init_leave (&application_type_id__volatile, application_type_id);
	}
	return application_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



