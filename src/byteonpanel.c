/* byteonpanel.c generated by valac 0.44.3, the Vala compiler
 * generated from byteonpanel.vala, do not modify */

#include <glib.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <stdio.h>
#include <glib/gstdio.h>
#include <cairo.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <config.h>
#include <gdk-pixbuf/gdk-pixbuf.h>

#define TYPE_BYTE_STAT (byte_stat_get_type ())
typedef struct _ByteStat ByteStat;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_IFACE (iface_get_type ())
#define IFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IFACE, IFace))
#define IFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IFACE, IFaceClass))
#define IS_IFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IFACE))
#define IS_IFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IFACE))
#define IFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IFACE, IFaceClass))

typedef struct _IFace IFace;
typedef struct _IFaceClass IFaceClass;
typedef struct _IFacePrivate IFacePrivate;
enum  {
	IFACE_0_PROPERTY,
	IFACE_ISUP_PROPERTY,
	IFACE_NUM_PROPERTIES
};
static GParamSpec* iface_properties[IFACE_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _byte_stat_free0(var) ((var == NULL) ? NULL : (var = (byte_stat_free (var), NULL)))

#define TYPE_STATUS_ICON_IF (status_icon_if_get_type ())
#define STATUS_ICON_IF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_STATUS_ICON_IF, StatusIconIF))
#define STATUS_ICON_IF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_STATUS_ICON_IF, StatusIconIFClass))
#define IS_STATUS_ICON_IF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_STATUS_ICON_IF))
#define IS_STATUS_ICON_IF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_STATUS_ICON_IF))
#define STATUS_ICON_IF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_STATUS_ICON_IF, StatusIconIFClass))

typedef struct _StatusIconIF StatusIconIF;
typedef struct _StatusIconIFClass StatusIconIFClass;
typedef struct _StatusIconIFPrivate StatusIconIFPrivate;

#define TYPE_APPLICATION (application_get_type ())
#define APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_APPLICATION, Application))
#define APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_APPLICATION, ApplicationClass))
#define IS_APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_APPLICATION))
#define IS_APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_APPLICATION))
#define APPLICATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_APPLICATION, ApplicationClass))

typedef struct _Application Application;
typedef struct _ApplicationClass ApplicationClass;
enum  {
	STATUS_ICON_IF_0_PROPERTY,
	STATUS_ICON_IF_NUM_PROPERTIES
};
static GParamSpec* status_icon_if_properties[STATUS_ICON_IF_NUM_PROPERTIES];
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))

#define STATUS_ICON_IF_TYPE_TRANS_SPEED (status_icon_if_trans_speed_get_type ())
typedef struct _StatusIconIFTransSpeed StatusIconIFTransSpeed;
typedef struct _ApplicationPrivate ApplicationPrivate;
enum  {
	APPLICATION_0_PROPERTY,
	APPLICATION_NUM_PROPERTIES
};
static GParamSpec* application_properties[APPLICATION_NUM_PROPERTIES];
#define _g_tree_unref0(var) ((var == NULL) ? NULL : (var = (g_tree_unref (var), NULL)))
typedef struct _Block1Data Block1Data;

struct _ByteStat {
	gdouble time_stamp;
	guint64 rx_total;
	gdouble rx_speed;
	guint64 tx_total;
	gdouble tx_speed;
	gdouble total_speed;
};

struct _IFace {
	GObject parent_instance;
	IFacePrivate * priv;
	gchar* iface_id;
	guint maxlen;
	GQueue* flow_queue;
};

struct _IFaceClass {
	GObjectClass parent_class;
};

struct _IFacePrivate {
	gchar* iface_path;
	gchar* rx_path;
	gchar* tx_path;
	gchar* operstate_path;
	GTimeVal tval;
};

struct _StatusIconIF {
	GObject parent_instance;
	StatusIconIFPrivate * priv;
	IFace* iface;
	gfloat portion;
	gfloat portion_low;
	gfloat rate_low;
	guint update_timeout;
	guint update_scale_timeout;
};

struct _StatusIconIFClass {
	GObjectClass parent_class;
};

struct _StatusIconIFPrivate {
	Application* app;
	cairo_t* ctx;
	cairo_surface_t* surface;
	gdouble scale;
	GtkStatusIcon* statusicon;
	GtkMenu* menu;
	guint update_id;
	guint update_scale_id;
	gint margin;
	guint* color_step;
	gint color_step_length1;
	gint _color_step_size_;
	gchar** rx_color_strings;
	gint rx_color_strings_length1;
	gint _rx_color_strings_size_;
	gchar** tx_color_strings;
	gint tx_color_strings_length1;
	gint _tx_color_strings_size_;
	GdkRGBA* rx_colors;
	gint rx_colors_length1;
	gint _rx_colors_size_;
	GdkRGBA* tx_colors;
	gint tx_colors_length1;
	gint _tx_colors_size_;
};

struct _StatusIconIFTransSpeed {
	gdouble* rx_list;
	gint rx_list_length1;
	gint _rx_list_size_;
	gdouble* tx_list;
	gint tx_list_length1;
	gint _tx_list_size_;
};

struct _Application {
	GObject parent_instance;
	ApplicationPrivate * priv;
};

struct _ApplicationClass {
	GObjectClass parent_class;
};

struct _ApplicationPrivate {
	GTree* iface_map;
	guint iface_update_timeout;
	gulong about_response_id;
};

struct _Block1Data {
	int _ref_count_;
	Application* self;
	gchar** key2remove;
	gint key2remove_length1;
	gint _key2remove_size_;
};

static gint IFace_private_offset;
static gpointer iface_parent_class = NULL;
static gint StatusIconIF_private_offset;
static gpointer status_icon_if_parent_class = NULL;
static gint Application_private_offset;
static gpointer application_parent_class = NULL;

#define fdelta 1E-9
#define MAX_SLOT ((guint) 48)
#define MIN_STATUS_ICON_SIZE 16
#define SYS_NET_PATH "/sys/class/net"
GType byte_stat_get_type (void) G_GNUC_CONST;
ByteStat* byte_stat_dup (const ByteStat* self);
void byte_stat_free (ByteStat* self);
gchar* humanize_number (gdouble num,
                        gfloat step,
                        const gchar* unit_string);
GType iface_get_type (void) G_GNUC_CONST;
static void _byte_stat_free0_ (gpointer var);
static inline void _g_queue_free__byte_stat_free0_ (GQueue* self);
IFace* iface_new (const gchar* if_name);
IFace* iface_construct (GType object_type,
                        const gchar* if_name);
void iface_update (IFace* self);
gboolean iface_get_isup (IFace* self);
static void iface_finalize (GObject * obj);
static void _vala_iface_get_property (GObject * object,
                               guint property_id,
                               GValue * value,
                               GParamSpec * pspec);
GType status_icon_if_get_type (void) G_GNUC_CONST;
GType application_get_type (void) G_GNUC_CONST;
StatusIconIF* status_icon_if_new (Application* app_obj,
                                  IFace* iface_obj);
StatusIconIF* status_icon_if_construct (GType object_type,
                                        Application* app_obj,
                                        IFace* iface_obj);
static void _vala_array_add1 (GdkRGBA* * array,
                       int* length,
                       int* size,
                       const GdkRGBA* value);
static void _vala_array_add2 (GdkRGBA* * array,
                       int* length,
                       int* size,
                       const GdkRGBA* value);
static void status_icon_if_setup_icon (StatusIconIF* self);
static gboolean status_icon_if_on_status_icon_size_changed (StatusIconIF* self,
                                                     GtkStatusIcon* sicon,
                                                     gint size);
static gboolean _status_icon_if_on_status_icon_size_changed_gtk_status_icon_size_changed (GtkStatusIcon* _sender,
                                                                                   gint size,
                                                                                   gpointer self);
static void status_icon_if_setup_menu (StatusIconIF* self);
gboolean status_icon_if_update_scale (StatusIconIF* self);
static gboolean _status_icon_if_update_scale_gsource_func (gpointer self);
static void status_icon_if_on_popup_menu (StatusIconIF* self,
                                   guint button,
                                   guint atime);
void application_on_about_dialog_show (Application* self,
                                       GtkAction* act);
static void _application_on_about_dialog_show_gtk_action_activate (GtkAction* _sender,
                                                            gpointer self);
void status_icon_if_on_quit (StatusIconIF* self,
                             GtkAction* act);
static void _status_icon_if_on_quit_gtk_action_activate (GtkAction* _sender,
                                                  gpointer self);
static void _status_icon_if_on_popup_menu_gtk_status_icon_popup_menu (GtkStatusIcon* _sender,
                                                               guint button,
                                                               guint activate_time,
                                                               gpointer self);
static gchar* status_icon_if_make_tooltip (StatusIconIF* self);
static gdouble status_icon_if_max_total_speed (StatusIconIF* self,
                                        GQueue* somed);
static GType status_icon_if_trans_speed_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static StatusIconIFTransSpeed* status_icon_if_trans_speed_dup (const StatusIconIFTransSpeed* self);
static void status_icon_if_trans_speed_free (StatusIconIFTransSpeed* self);
static void status_icon_if_trans_speed_copy (const StatusIconIFTransSpeed* self,
                                      StatusIconIFTransSpeed* dest);
static void status_icon_if_trans_speed_destroy (StatusIconIFTransSpeed* self);
static void status_icon_if_get_speed (StatusIconIF* self,
                               gdouble max_speed,
                               StatusIconIFTransSpeed* result);
static gdouble* _vala_array_dup1 (gdouble* self,
                           int length);
static gdouble* _vala_array_dup2 (gdouble* self,
                           int length);
static gint status_icon_if_color_index_by_speed (StatusIconIF* self,
                                          gdouble current_speed);
gboolean status_icon_if_update (StatusIconIF* self);
static gdouble* _vala_array_dup3 (gdouble* self,
                           int length);
static gdouble* _vala_array_dup4 (gdouble* self,
                           int length);
void status_icon_if_start_timers (StatusIconIF* self);
static gboolean _status_icon_if_update_gsource_func (gpointer self);
void application_quit (Application* self);
void status_icon_if_on_destroy (StatusIconIF* self);
static gdouble* _vala_array_dup5 (gdouble* self,
                           int length);
static gdouble* _vala_array_dup6 (gdouble* self,
                           int length);
static void status_icon_if_finalize (GObject * obj);
static Application* application_new (void);
static Application* application_construct (GType object_type);
static gint __lambda4_ (Application* self,
                 const gchar* a,
                 const gchar* b);
static gint ___lambda4__gcompare_data_func (gconstpointer a,
                                     gconstpointer b,
                                     gpointer self);
static void _g_object_unref_gdestroy_notify (void* data);
static gboolean application_update_iface (Application* self);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static gboolean __lambda5_ (Block1Data* _data1_,
                     const gchar* k,
                     StatusIconIF* v);
static void _vala_array_add3 (gchar** * array,
                       int* length,
                       int* size,
                       gchar* value);
static gboolean ___lambda5__gtraverse_func (gconstpointer key,
                                     gconstpointer value,
                                     gpointer self);
static void __lambda6_ (Application* self,
                 GtkDialog* a,
                 gint b);
static void ___lambda6__gtk_dialog_response (GtkDialog* _sender,
                                      gint response_id,
                                      gpointer self);
void application_start (Application* self);
static gboolean _application_update_iface_gsource_func (gpointer self);
gint application_main (gchar** args,
                       gint args_length1);
static void application_finalize (GObject * obj);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);

ByteStat*
byte_stat_dup (const ByteStat* self)
{
	ByteStat* dup;
	dup = g_new0 (ByteStat, 1);
	memcpy (dup, self, sizeof (ByteStat));
	return dup;
}

void
byte_stat_free (ByteStat* self)
{
	g_free (self);
}

GType
byte_stat_get_type (void)
{
	static volatile gsize byte_stat_type_id__volatile = 0;
	if (g_once_init_enter (&byte_stat_type_id__volatile)) {
		GType byte_stat_type_id;
		byte_stat_type_id = g_boxed_type_register_static ("ByteStat", (GBoxedCopyFunc) byte_stat_dup, (GBoxedFreeFunc) byte_stat_free);
		g_once_init_leave (&byte_stat_type_id__volatile, byte_stat_type_id);
	}
	return byte_stat_type_id__volatile;
}

gchar*
humanize_number (gdouble num,
                 gfloat step,
                 const gchar* unit_string)
{
	gchar* result = NULL;
	gchar** ends = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar** _tmp9_;
	gint ends_length1;
	gint _ends_size_;
	gchar* the_end = NULL;
	gchar** _tmp10_;
	gint _tmp10__length1;
	gchar** _tmp11_;
	gint _tmp11__length1;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	gchar** _tmp14_;
	gint _tmp14__length1;
	const gchar* _tmp18_;
	gchar* _tmp19_;
	g_return_val_if_fail (unit_string != NULL, NULL);
	_tmp0_ = g_strdup ("");
	_tmp1_ = g_strdup ("K");
	_tmp2_ = g_strdup ("M");
	_tmp3_ = g_strdup ("G");
	_tmp4_ = g_strdup ("T");
	_tmp5_ = g_strdup ("P");
	_tmp6_ = g_strdup ("E");
	_tmp7_ = g_strdup ("Z");
	_tmp8_ = g_strdup ("Y");
	_tmp9_ = g_new0 (gchar*, 9 + 1);
	_tmp9_[0] = _tmp0_;
	_tmp9_[1] = _tmp1_;
	_tmp9_[2] = _tmp2_;
	_tmp9_[3] = _tmp3_;
	_tmp9_[4] = _tmp4_;
	_tmp9_[5] = _tmp5_;
	_tmp9_[6] = _tmp6_;
	_tmp9_[7] = _tmp7_;
	_tmp9_[8] = _tmp8_;
	ends = _tmp9_;
	ends_length1 = 9;
	_ends_size_ = ends_length1;
	_tmp10_ = ends;
	_tmp10__length1 = ends_length1;
	_tmp11_ = ends;
	_tmp11__length1 = ends_length1;
	_tmp12_ = _tmp10_[_tmp11__length1 - 1];
	_tmp13_ = g_strdup (_tmp12_);
	the_end = _tmp13_;
	_tmp14_ = ends;
	_tmp14__length1 = ends_length1;
	{
		gchar** i_collection = NULL;
		gint i_collection_length1 = 0;
		gint _i_collection_size_ = 0;
		gint i_it = 0;
		i_collection = _tmp14_;
		i_collection_length1 = _tmp14__length1;
		for (i_it = 0; i_it < _tmp14__length1; i_it = i_it + 1) {
			gchar* _tmp15_;
			gchar* i = NULL;
			_tmp15_ = g_strdup (i_collection[i_it]);
			i = _tmp15_;
			{
				if (num < ((gdouble) step)) {
					const gchar* _tmp16_;
					gchar* _tmp17_;
					_tmp16_ = i;
					_tmp17_ = g_strdup (_tmp16_);
					_g_free0 (the_end);
					the_end = _tmp17_;
					_g_free0 (i);
					break;
				}
				num = num / step;
				_g_free0 (i);
			}
		}
	}
	_tmp18_ = the_end;
	_tmp19_ = g_strdup_printf ("%.2f%s%s", num, _tmp18_, unit_string);
	result = _tmp19_;
	_g_free0 (the_end);
	ends = (_vala_array_free (ends, ends_length1, (GDestroyNotify) g_free), NULL);
	return result;
}

static inline gpointer
iface_get_instance_private (IFace* self)
{
	return G_STRUCT_MEMBER_P (self, IFace_private_offset);
}

static void
_byte_stat_free0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (byte_stat_free (var), NULL));
}

static inline void
_g_queue_free__byte_stat_free0_ (GQueue* self)
{
	g_queue_free_full (self, (GDestroyNotify) _byte_stat_free0_);
}

IFace*
iface_construct (GType object_type,
                 const gchar* if_name)
{
	IFace * self = NULL;
	gchar* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	const gchar* _tmp7_;
	gchar* _tmp8_;
	GQueue* _tmp9_;
	g_return_val_if_fail (if_name != NULL, NULL);
	self = (IFace*) g_object_new (object_type, NULL);
	_tmp0_ = g_strdup (if_name);
	_g_free0 (self->iface_id);
	self->iface_id = _tmp0_;
	_tmp1_ = self->iface_id;
	_tmp2_ = g_build_filename (SYS_NET_PATH, _tmp1_, NULL);
	_g_free0 (self->priv->iface_path);
	self->priv->iface_path = _tmp2_;
	_tmp3_ = self->priv->iface_path;
	_tmp4_ = g_build_filename (_tmp3_, "statistics", "rx_bytes", NULL);
	_g_free0 (self->priv->rx_path);
	self->priv->rx_path = _tmp4_;
	_tmp5_ = self->priv->iface_path;
	_tmp6_ = g_build_filename (_tmp5_, "statistics", "tx_bytes", NULL);
	_g_free0 (self->priv->tx_path);
	self->priv->tx_path = _tmp6_;
	_tmp7_ = self->priv->iface_path;
	_tmp8_ = g_build_filename (_tmp7_, "operstate", NULL);
	_g_free0 (self->priv->operstate_path);
	self->priv->operstate_path = _tmp8_;
	_tmp9_ = g_queue_new ();
	(self->flow_queue == NULL) ? NULL : (self->flow_queue = (_g_queue_free__byte_stat_free0_ (self->flow_queue), NULL));
	self->flow_queue = _tmp9_;
	g_get_current_time (&self->priv->tval);
	return self;
}

IFace*
iface_new (const gchar* if_name)
{
	return iface_construct (TYPE_IFACE, if_name);
}

static guint64
uint64_parse (const gchar* str)
{
	guint64 result = 0ULL;
	g_return_val_if_fail (str != NULL, 0ULL);
	result = g_ascii_strtoull (str, NULL, (guint) 0);
	return result;
}

static gpointer
_byte_stat_dup0 (gpointer self)
{
	return self ? byte_stat_dup (self) : NULL;
}

void
iface_update (IFace* self)
{
	gdouble time_stamp = 0.0;
	gdouble rx_rate = 0.0;
	gdouble tx_rate = 0.0;
	guint64 rx = 0ULL;
	guint64 tx = 0ULL;
	GTimeVal _tmp23_;
	GTimeVal _tmp24_;
	ByteStat* last_stat = NULL;
	GQueue* _tmp25_;
	gconstpointer _tmp26_;
	ByteStat* _tmp27_;
	GQueue* _tmp28_;
	ByteStat item = {0};
	ByteStat _tmp32_ = {0};
	GQueue* _tmp33_;
	ByteStat _tmp34_;
	ByteStat* _tmp35_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	tx_rate = (gdouble) 0;
	rx_rate = tx_rate;
	{
		guint8* rx_buf = NULL;
		guint8* _tmp0_;
		gint rx_buf_length1;
		gint _rx_buf_size_;
		guint8* tx_buf = NULL;
		guint8* _tmp1_;
		gint tx_buf_length1;
		gint _tx_buf_size_;
		gsize rlen = 0UL;
		GFile* fd = NULL;
		const gchar* _tmp2_;
		GFile* _tmp3_;
		GFileInputStream* rx_stream = NULL;
		GFile* _tmp4_;
		GFileInputStream* _tmp5_;
		const gchar* _tmp6_;
		GFile* _tmp7_;
		GFileInputStream* tx_stream = NULL;
		GFile* _tmp8_;
		GFileInputStream* _tmp9_;
		GFileInputStream* _tmp10_;
		guint8* _tmp11_;
		gint _tmp11__length1;
		gsize _tmp12_ = 0UL;
		GFileInputStream* _tmp13_;
		guint8* _tmp14_;
		gint _tmp14__length1;
		gsize _tmp15_ = 0UL;
		GFileInputStream* _tmp16_;
		GFileInputStream* _tmp17_;
		guint8* _tmp18_;
		gint _tmp18__length1;
		guint8* _tmp19_;
		gint _tmp19__length1;
		_tmp0_ = g_new0 (guint8, 64);
		rx_buf = _tmp0_;
		rx_buf_length1 = 64;
		_rx_buf_size_ = rx_buf_length1;
		_tmp1_ = g_new0 (guint8, 64);
		tx_buf = _tmp1_;
		tx_buf_length1 = 64;
		_tx_buf_size_ = tx_buf_length1;
		_tmp2_ = self->priv->rx_path;
		_tmp3_ = g_file_new_for_path (_tmp2_);
		fd = _tmp3_;
		_tmp4_ = fd;
		_tmp5_ = g_file_read (_tmp4_, NULL, &_inner_error0_);
		rx_stream = _tmp5_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (fd);
			tx_buf = (g_free (tx_buf), NULL);
			rx_buf = (g_free (rx_buf), NULL);
			goto __catch0_g_error;
		}
		_tmp6_ = self->priv->tx_path;
		_tmp7_ = g_file_new_for_path (_tmp6_);
		_g_object_unref0 (fd);
		fd = _tmp7_;
		_tmp8_ = fd;
		_tmp9_ = g_file_read (_tmp8_, NULL, &_inner_error0_);
		tx_stream = _tmp9_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (rx_stream);
			_g_object_unref0 (fd);
			tx_buf = (g_free (tx_buf), NULL);
			rx_buf = (g_free (rx_buf), NULL);
			goto __catch0_g_error;
		}
		g_get_current_time (&self->priv->tval);
		_tmp10_ = rx_stream;
		_tmp11_ = rx_buf;
		_tmp11__length1 = rx_buf_length1;
		g_input_stream_read_all ((GInputStream*) _tmp10_, _tmp11_, (gsize) _tmp11__length1, &_tmp12_, NULL, &_inner_error0_);
		rlen = _tmp12_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (tx_stream);
			_g_object_unref0 (rx_stream);
			_g_object_unref0 (fd);
			tx_buf = (g_free (tx_buf), NULL);
			rx_buf = (g_free (rx_buf), NULL);
			goto __catch0_g_error;
		}
		_tmp13_ = tx_stream;
		_tmp14_ = tx_buf;
		_tmp14__length1 = tx_buf_length1;
		g_input_stream_read_all ((GInputStream*) _tmp13_, _tmp14_, (gsize) _tmp14__length1, &_tmp15_, NULL, &_inner_error0_);
		rlen = _tmp15_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (tx_stream);
			_g_object_unref0 (rx_stream);
			_g_object_unref0 (fd);
			tx_buf = (g_free (tx_buf), NULL);
			rx_buf = (g_free (rx_buf), NULL);
			goto __catch0_g_error;
		}
		_tmp16_ = rx_stream;
		g_input_stream_close ((GInputStream*) _tmp16_, NULL, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (tx_stream);
			_g_object_unref0 (rx_stream);
			_g_object_unref0 (fd);
			tx_buf = (g_free (tx_buf), NULL);
			rx_buf = (g_free (rx_buf), NULL);
			goto __catch0_g_error;
		}
		_tmp17_ = tx_stream;
		g_input_stream_close ((GInputStream*) _tmp17_, NULL, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (tx_stream);
			_g_object_unref0 (rx_stream);
			_g_object_unref0 (fd);
			tx_buf = (g_free (tx_buf), NULL);
			rx_buf = (g_free (rx_buf), NULL);
			goto __catch0_g_error;
		}
		_tmp18_ = rx_buf;
		_tmp18__length1 = rx_buf_length1;
		rx = uint64_parse ((const gchar*) _tmp18_);
		_tmp19_ = tx_buf;
		_tmp19__length1 = tx_buf_length1;
		tx = uint64_parse ((const gchar*) _tmp19_);
		_g_object_unref0 (tx_stream);
		_g_object_unref0 (rx_stream);
		_g_object_unref0 (fd);
		tx_buf = (g_free (tx_buf), NULL);
		rx_buf = (g_free (rx_buf), NULL);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		FILE* _tmp20_;
		GError* _tmp21_;
		const gchar* _tmp22_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp20_ = stderr;
		_tmp21_ = e;
		_tmp22_ = _tmp21_->message;
		fprintf (_tmp20_, "Error: %s\n", _tmp22_);
		_g_error_free0 (e);
		return;
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_tmp23_ = self->priv->tval;
	_tmp24_ = self->priv->tval;
	time_stamp = _tmp23_.tv_sec + (_tmp24_.tv_usec / 1000000.0);
	_tmp25_ = self->flow_queue;
	_tmp26_ = g_queue_peek_tail (_tmp25_);
	_tmp27_ = _byte_stat_dup0 ((ByteStat*) _tmp26_);
	last_stat = _tmp27_;
	_tmp28_ = self->flow_queue;
	if (_tmp28_->length > ((guint) 1)) {
		gdouble laps = 0.0;
		ByteStat* _tmp29_;
		_tmp29_ = last_stat;
		laps = time_stamp - (*_tmp29_).time_stamp;
		if (laps == 0.0) {
			rx_rate = 0.0;
			tx_rate = 0.0;
		} else {
			ByteStat* _tmp30_;
			ByteStat* _tmp31_;
			_tmp30_ = last_stat;
			rx_rate = (rx - (*_tmp30_).rx_total) / laps;
			_tmp31_ = last_stat;
			tx_rate = (tx - (*_tmp31_).tx_total) / laps;
		}
	}
	_tmp32_.time_stamp = time_stamp;
	_tmp32_.rx_total = rx;
	_tmp32_.rx_speed = rx_rate;
	_tmp32_.tx_total = tx;
	_tmp32_.tx_speed = tx_rate;
	_tmp32_.total_speed = rx_rate + tx_rate;
	item = _tmp32_;
	_tmp33_ = self->flow_queue;
	_tmp34_ = item;
	_tmp35_ = _byte_stat_dup0 (&_tmp34_);
	g_queue_push_tail (_tmp33_, _tmp35_);
	while (TRUE) {
		GQueue* _tmp36_;
		GQueue* _tmp37_;
		gpointer _tmp38_;
		ByteStat* _tmp39_;
		_tmp36_ = self->flow_queue;
		if (!(_tmp36_->length > self->maxlen)) {
			break;
		}
		_tmp37_ = self->flow_queue;
		_tmp38_ = g_queue_pop_head (_tmp37_);
		_tmp39_ = (ByteStat*) _tmp38_;
		_byte_stat_free0 (_tmp39_);
	}
	_byte_stat_free0 (last_stat);
}

static gchar*
string_strip (const gchar* self)
{
	gchar* result = NULL;
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	const gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strstrip (_tmp1_);
	result = _result_;
	return result;
}

gboolean
iface_get_isup (IFace* self)
{
	gboolean result;
	gchar* text = NULL;
	const gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gboolean _tmp12_;
	GError* _inner_error0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	{
		const gchar* _tmp0_;
		gchar* _tmp1_ = NULL;
		_tmp0_ = self->priv->operstate_path;
		g_file_get_contents (_tmp0_, &_tmp1_, NULL, &_inner_error0_);
		_g_free0 (text);
		text = _tmp1_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			gboolean _tmp2_ = FALSE;
			if (_inner_error0_->domain == G_FILE_ERROR) {
				goto __catch1_g_file_error;
			}
			_g_free0 (text);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return _tmp2_;
		}
	}
	goto __finally1;
	__catch1_g_file_error:
	{
		GError* e = NULL;
		FILE* _tmp3_;
		GError* _tmp4_;
		const gchar* _tmp5_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp3_ = stderr;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		fprintf (_tmp3_, "Error: %s\n", _tmp5_);
		result = FALSE;
		_g_error_free0 (e);
		_g_free0 (text);
		return result;
	}
	__finally1:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		gboolean _tmp6_ = FALSE;
		_g_free0 (text);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return _tmp6_;
	}
	_tmp7_ = text;
	_tmp8_ = string_strip (_tmp7_);
	_tmp9_ = _tmp8_;
	_tmp10_ = g_utf8_strdown (_tmp9_, (gssize) -1);
	_tmp11_ = _tmp10_;
	_tmp12_ = g_strcmp0 (_tmp11_, "up") == 0;
	_g_free0 (_tmp11_);
	_g_free0 (_tmp9_);
	result = _tmp12_;
	_g_free0 (text);
	return result;
}

static void
iface_class_init (IFaceClass * klass,
                  gpointer klass_data)
{
	iface_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &IFace_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_iface_get_property;
	G_OBJECT_CLASS (klass)->finalize = iface_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), IFACE_ISUP_PROPERTY, iface_properties[IFACE_ISUP_PROPERTY] = g_param_spec_boolean ("isup", "isup", "isup", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}

static void
iface_instance_init (IFace * self,
                     gpointer klass)
{
	self->priv = iface_get_instance_private (self);
	self->maxlen = MAX_SLOT;
}

static void
iface_finalize (GObject * obj)
{
	IFace * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_IFACE, IFace);
	_g_free0 (self->priv->iface_path);
	_g_free0 (self->priv->rx_path);
	_g_free0 (self->priv->tx_path);
	_g_free0 (self->priv->operstate_path);
	_g_free0 (self->iface_id);
	(self->flow_queue == NULL) ? NULL : (self->flow_queue = (_g_queue_free__byte_stat_free0_ (self->flow_queue), NULL));
	G_OBJECT_CLASS (iface_parent_class)->finalize (obj);
}

GType
iface_get_type (void)
{
	static volatile gsize iface_type_id__volatile = 0;
	if (g_once_init_enter (&iface_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IFaceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) iface_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IFace), 0, (GInstanceInitFunc) iface_instance_init, NULL };
		GType iface_type_id;
		iface_type_id = g_type_register_static (G_TYPE_OBJECT, "IFace", &g_define_type_info, 0);
		IFace_private_offset = g_type_add_instance_private (iface_type_id, sizeof (IFacePrivate));
		g_once_init_leave (&iface_type_id__volatile, iface_type_id);
	}
	return iface_type_id__volatile;
}

static void
_vala_iface_get_property (GObject * object,
                          guint property_id,
                          GValue * value,
                          GParamSpec * pspec)
{
	IFace * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_IFACE, IFace);
	switch (property_id) {
		case IFACE_ISUP_PROPERTY:
		g_value_set_boolean (value, iface_get_isup (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
status_icon_if_get_instance_private (StatusIconIF* self)
{
	return G_STRUCT_MEMBER_P (self, StatusIconIF_private_offset);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static void
_vala_array_add1 (GdkRGBA* * array,
                  int* length,
                  int* size,
                  const GdkRGBA* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GdkRGBA, *array, *size);
	}
	(*array)[(*length)++] = *value;
}

static void
_vala_array_add2 (GdkRGBA* * array,
                  int* length,
                  int* size,
                  const GdkRGBA* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GdkRGBA, *array, *size);
	}
	(*array)[(*length)++] = *value;
}

StatusIconIF*
status_icon_if_construct (GType object_type,
                          Application* app_obj,
                          IFace* iface_obj)
{
	StatusIconIF * self = NULL;
	Application* _tmp0_;
	IFace* _tmp1_;
	IFace* _tmp13_;
	g_return_val_if_fail (app_obj != NULL, NULL);
	g_return_val_if_fail (iface_obj != NULL, NULL);
	self = (StatusIconIF*) g_object_new (object_type, NULL);
	_tmp0_ = _g_object_ref0 (app_obj);
	_g_object_unref0 (self->priv->app);
	self->priv->app = _tmp0_;
	_tmp1_ = _g_object_ref0 (iface_obj);
	_g_object_unref0 (self->iface);
	self->iface = _tmp1_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				guint* _tmp4_;
				gint _tmp4__length1;
				GdkRGBA color = {0};
				gchar** _tmp5_;
				gint _tmp5__length1;
				const gchar* _tmp6_;
				GdkRGBA* _tmp7_;
				gint _tmp7__length1;
				GdkRGBA _tmp8_;
				gchar** _tmp9_;
				gint _tmp9__length1;
				const gchar* _tmp10_;
				GdkRGBA* _tmp11_;
				gint _tmp11__length1;
				GdkRGBA _tmp12_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp4_ = self->priv->color_step;
				_tmp4__length1 = self->priv->color_step_length1;
				if (!(i < _tmp4__length1)) {
					break;
				}
				memset (&color, 0, sizeof (GdkRGBA));
				_tmp5_ = self->priv->rx_color_strings;
				_tmp5__length1 = self->priv->rx_color_strings_length1;
				_tmp6_ = _tmp5_[i];
				gdk_rgba_parse (&color, _tmp6_);
				_tmp7_ = self->priv->rx_colors;
				_tmp7__length1 = self->priv->rx_colors_length1;
				_tmp8_ = color;
				_vala_array_add1 (&self->priv->rx_colors, &self->priv->rx_colors_length1, &self->priv->_rx_colors_size_, &_tmp8_);
				memset (&color, 0, sizeof (GdkRGBA));
				_tmp9_ = self->priv->tx_color_strings;
				_tmp9__length1 = self->priv->tx_color_strings_length1;
				_tmp10_ = _tmp9_[i];
				gdk_rgba_parse (&color, _tmp10_);
				_tmp11_ = self->priv->tx_colors;
				_tmp11__length1 = self->priv->tx_colors_length1;
				_tmp12_ = color;
				_vala_array_add2 (&self->priv->tx_colors, &self->priv->tx_colors_length1, &self->priv->_tx_colors_size_, &_tmp12_);
			}
		}
	}
	status_icon_if_setup_icon (self);
	_tmp13_ = self->iface;
	self->update_scale_timeout = _tmp13_->maxlen * self->update_timeout;
	return self;
}

StatusIconIF*
status_icon_if_new (Application* app_obj,
                    IFace* iface_obj)
{
	return status_icon_if_construct (TYPE_STATUS_ICON_IF, app_obj, iface_obj);
}

static gboolean
_status_icon_if_on_status_icon_size_changed_gtk_status_icon_size_changed (GtkStatusIcon* _sender,
                                                                          gint size,
                                                                          gpointer self)
{
	gboolean result;
	result = status_icon_if_on_status_icon_size_changed ((StatusIconIF*) self, _sender, size);
	return result;
}

static void
status_icon_if_setup_icon (StatusIconIF* self)
{
	GtkStatusIcon* _tmp0_;
	GtkStatusIcon* _tmp1_;
	GtkStatusIcon* _tmp2_;
	GtkStatusIcon* _tmp3_;
	GtkStatusIcon* _tmp4_;
	GtkStatusIcon* _tmp5_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_status_icon_new ();
	_g_object_unref0 (self->priv->statusicon);
	self->priv->statusicon = _tmp0_;
	_tmp1_ = self->priv->statusicon;
	gtk_status_icon_set_visible (_tmp1_, TRUE);
	_tmp2_ = self->priv->statusicon;
	gtk_status_icon_set_title (_tmp2_, PACKAGE_NAME);
	_tmp3_ = self->priv->statusicon;
	g_signal_connect_object (_tmp3_, "size-changed", (GCallback) _status_icon_if_on_status_icon_size_changed_gtk_status_icon_size_changed, self, 0);
	status_icon_if_setup_menu (self);
	_tmp4_ = self->priv->statusicon;
	_tmp5_ = self->priv->statusicon;
	status_icon_if_on_status_icon_size_changed (self, _tmp4_, gtk_status_icon_get_size (_tmp5_));
}

static gboolean
_status_icon_if_update_scale_gsource_func (gpointer self)
{
	gboolean result;
	result = status_icon_if_update_scale ((StatusIconIF*) self);
	return result;
}

static gboolean
status_icon_if_on_status_icon_size_changed (StatusIconIF* self,
                                            GtkStatusIcon* sicon,
                                            gint size)
{
	gboolean result = FALSE;
	gint hsize = 0;
	cairo_surface_t* _tmp0_;
	cairo_surface_t* _tmp1_;
	cairo_t* _tmp2_;
	IFace* _tmp3_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (sicon != NULL, FALSE);
	if (!gtk_status_icon_is_embedded (sicon)) {
		result = FALSE;
		return result;
	}
	hsize = size;
	if (size >= MIN_STATUS_ICON_SIZE) {
		hsize = size - (self->priv->margin * 2);
	}
	_tmp0_ = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, size, hsize);
	_cairo_surface_destroy0 (self->priv->surface);
	self->priv->surface = _tmp0_;
	_tmp1_ = self->priv->surface;
	_tmp2_ = cairo_create (_tmp1_);
	_cairo_destroy0 (self->priv->ctx);
	self->priv->ctx = _tmp2_;
	_tmp3_ = self->iface;
	if (((guint) size) < _tmp3_->maxlen) {
		IFace* _tmp4_;
		IFace* _tmp5_;
		_tmp4_ = self->iface;
		_tmp4_->maxlen = (guint) size;
		_tmp5_ = self->iface;
		self->update_scale_timeout = _tmp5_->maxlen * self->update_timeout;
		if (self->priv->update_scale_id > ((guint) 0)) {
			g_source_remove (self->priv->update_scale_id);
			self->priv->update_scale_id = (guint) -1;
		}
		self->priv->update_scale_id = g_timeout_add_full (G_PRIORITY_DEFAULT, self->update_scale_timeout, _status_icon_if_update_scale_gsource_func, g_object_ref (self), g_object_unref);
	}
	result = TRUE;
	return result;
}

static void
status_icon_if_on_popup_menu (StatusIconIF* self,
                              guint button,
                              guint atime)
{
	GtkMenu* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->menu;
	gtk_menu_popup (_tmp0_, NULL, NULL, NULL, NULL, button, (guint32) atime);
}

static void
_application_on_about_dialog_show_gtk_action_activate (GtkAction* _sender,
                                                       gpointer self)
{
	application_on_about_dialog_show ((Application*) self, _sender);
}

static void
_status_icon_if_on_quit_gtk_action_activate (GtkAction* _sender,
                                             gpointer self)
{
	status_icon_if_on_quit ((StatusIconIF*) self, _sender);
}

static void
_status_icon_if_on_popup_menu_gtk_status_icon_popup_menu (GtkStatusIcon* _sender,
                                                          guint button,
                                                          guint activate_time,
                                                          gpointer self)
{
	status_icon_if_on_popup_menu ((StatusIconIF*) self, button, activate_time);
}

static void
status_icon_if_setup_menu (StatusIconIF* self)
{
	static const char ui_info[] = "\n" \
"            <ui>\n" \
"                <popup name=\"Popup\">\n" \
"                    <menuitem action=\"About\"/>\n" \
"                    <separator/>\n" \
"                    <menuitem action=\"Quit\"/>\n" \
"                </popup>\n" \
"            </ui>\n" \
"        ";
	GtkActionGroup* actions = NULL;
	GtkActionGroup* _tmp0_;
	GtkAction* action = NULL;
	GtkAction* _tmp1_;
	GtkAction* _tmp2_;
	Application* _tmp3_;
	GtkActionGroup* _tmp4_;
	GtkAction* _tmp5_;
	GtkAction* _tmp6_;
	GtkAction* _tmp7_;
	GtkActionGroup* _tmp8_;
	GtkAction* _tmp9_;
	GtkUIManager* ui = NULL;
	GtkUIManager* _tmp10_;
	GtkUIManager* _tmp11_;
	GtkActionGroup* _tmp12_;
	GtkUIManager* _tmp17_;
	GtkWidget* _tmp18_;
	GtkMenu* _tmp19_;
	GtkStatusIcon* _tmp20_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_action_group_new ("StatusIconPopup");
	actions = _tmp0_;
	_tmp1_ = gtk_action_new ("About", NULL, NULL, GTK_STOCK_ABOUT);
	_g_object_unref0 (action);
	action = _tmp1_;
	_tmp2_ = action;
	_tmp3_ = self->priv->app;
	g_signal_connect_object (_tmp2_, "activate", (GCallback) _application_on_about_dialog_show_gtk_action_activate, _tmp3_, 0);
	_tmp4_ = actions;
	_tmp5_ = action;
	gtk_action_group_add_action (_tmp4_, _tmp5_);
	_tmp6_ = gtk_action_new ("Quit", NULL, NULL, GTK_STOCK_QUIT);
	_g_object_unref0 (action);
	action = _tmp6_;
	_tmp7_ = action;
	g_signal_connect_object (_tmp7_, "activate", (GCallback) _status_icon_if_on_quit_gtk_action_activate, self, 0);
	_tmp8_ = actions;
	_tmp9_ = action;
	gtk_action_group_add_action (_tmp8_, _tmp9_);
	_tmp10_ = gtk_ui_manager_new ();
	ui = _tmp10_;
	_tmp11_ = ui;
	_tmp12_ = actions;
	gtk_ui_manager_insert_action_group (_tmp11_, _tmp12_, 0);
	{
		GtkUIManager* _tmp13_;
		_tmp13_ = ui;
		gtk_ui_manager_add_ui_from_string (_tmp13_, ui_info, (gssize) -1, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch2_g_error;
		}
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError* e = NULL;
		FILE* _tmp14_;
		GError* _tmp15_;
		const gchar* _tmp16_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp14_ = stderr;
		_tmp15_ = e;
		_tmp16_ = _tmp15_->message;
		fprintf (_tmp14_, "Error: %s\n", _tmp16_);
		_g_error_free0 (e);
		_g_object_unref0 (ui);
		_g_object_unref0 (action);
		_g_object_unref0 (actions);
		return;
	}
	__finally2:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_object_unref0 (ui);
		_g_object_unref0 (action);
		_g_object_unref0 (actions);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_tmp17_ = ui;
	_tmp18_ = gtk_ui_manager_get_widget (_tmp17_, "/Popup");
	_tmp19_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp18_, gtk_menu_get_type ()) ? ((GtkMenu*) _tmp18_) : NULL);
	_g_object_unref0 (self->priv->menu);
	self->priv->menu = _tmp19_;
	_tmp20_ = self->priv->statusicon;
	g_signal_connect_object (_tmp20_, "popup-menu", (GCallback) _status_icon_if_on_popup_menu_gtk_status_icon_popup_menu, self, 0);
	_g_object_unref0 (ui);
	_g_object_unref0 (action);
	_g_object_unref0 (actions);
	return;
}

static gchar*
status_icon_if_make_tooltip (StatusIconIF* self)
{
	gchar* result = NULL;
	gdouble rx_av = 0.0;
	gdouble tx_av = 0.0;
	ByteStat* last_stat = NULL;
	IFace* _tmp0_;
	GQueue* _tmp1_;
	gconstpointer _tmp2_;
	ByteStat* _tmp3_;
	ByteStat* first_stat = NULL;
	IFace* _tmp4_;
	GQueue* _tmp5_;
	gconstpointer _tmp6_;
	ByteStat* _tmp7_;
	IFace* _tmp8_;
	GQueue* _tmp9_;
	gchar* rx_now = NULL;
	ByteStat* _tmp18_;
	gchar* _tmp19_;
	gchar* tx_now = NULL;
	ByteStat* _tmp20_;
	gchar* _tmp21_;
	gchar* rx_av_text = NULL;
	gchar* _tmp22_;
	gchar* tx_av_text = NULL;
	gchar* _tmp23_;
	gchar* txt = NULL;
	IFace* _tmp24_;
	const gchar* _tmp25_;
	gchar* _tmp26_;
	g_return_val_if_fail (self != NULL, NULL);
	tx_av = 0.0;
	rx_av = tx_av;
	_tmp0_ = self->iface;
	_tmp1_ = _tmp0_->flow_queue;
	_tmp2_ = g_queue_peek_tail (_tmp1_);
	_tmp3_ = _byte_stat_dup0 ((ByteStat*) _tmp2_);
	last_stat = _tmp3_;
	_tmp4_ = self->iface;
	_tmp5_ = _tmp4_->flow_queue;
	_tmp6_ = g_queue_peek_head (_tmp5_);
	_tmp7_ = _byte_stat_dup0 ((ByteStat*) _tmp6_);
	first_stat = _tmp7_;
	_tmp8_ = self->iface;
	_tmp9_ = _tmp8_->flow_queue;
	if (_tmp9_->length > ((guint) 1)) {
		ByteStat* _tmp10_;
		ByteStat* _tmp11_;
		ByteStat* _tmp12_;
		ByteStat* _tmp13_;
		ByteStat* _tmp14_;
		ByteStat* _tmp15_;
		ByteStat* _tmp16_;
		ByteStat* _tmp17_;
		_tmp10_ = last_stat;
		_tmp11_ = first_stat;
		_tmp12_ = last_stat;
		_tmp13_ = first_stat;
		rx_av = ((*_tmp10_).rx_total - (*_tmp11_).rx_total) / ((*_tmp12_).time_stamp - (*_tmp13_).time_stamp);
		_tmp14_ = last_stat;
		_tmp15_ = first_stat;
		_tmp16_ = last_stat;
		_tmp17_ = first_stat;
		tx_av = ((*_tmp14_).tx_total - (*_tmp15_).tx_total) / ((*_tmp16_).time_stamp - (*_tmp17_).time_stamp);
	}
	_tmp18_ = last_stat;
	_tmp19_ = humanize_number ((*_tmp18_).rx_speed, 1024.0f, "B");
	rx_now = _tmp19_;
	_tmp20_ = last_stat;
	_tmp21_ = humanize_number ((*_tmp20_).tx_speed, 1024.0f, "B");
	tx_now = _tmp21_;
	_tmp22_ = humanize_number (rx_av, 1024.0f, "B");
	rx_av_text = _tmp22_;
	_tmp23_ = humanize_number (tx_av, 1024.0f, "B");
	tx_av_text = _tmp23_;
	_tmp24_ = self->iface;
	_tmp25_ = _tmp24_->iface_id;
	_tmp26_ = g_strdup_printf ("Interface: %s\nIn/Out(current): %s/%s\nIn/Out(average): %s/%s", _tmp25_, rx_now, tx_now, rx_av_text, tx_av_text);
	txt = _tmp26_;
	result = txt;
	_g_free0 (tx_av_text);
	_g_free0 (rx_av_text);
	_g_free0 (tx_now);
	_g_free0 (rx_now);
	_byte_stat_free0 (first_stat);
	_byte_stat_free0 (last_stat);
	return result;
}

static gdouble
status_icon_if_max_total_speed (StatusIconIF* self,
                                GQueue* somed)
{
	gdouble result = 0.0;
	gdouble a = 0.0;
	g_return_val_if_fail (self != NULL, 0.0);
	g_return_val_if_fail (somed != NULL, 0.0);
	a = DBL_MIN;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				ByteStat* b = NULL;
				gconstpointer _tmp2_;
				ByteStat* _tmp3_;
				ByteStat* _tmp4_;
				if (!_tmp0_) {
					gint _tmp1_;
					_tmp1_ = i;
					i = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				if (!(((guint) i) < somed->length)) {
					break;
				}
				_tmp2_ = g_queue_peek_nth (somed, (guint) i);
				_tmp3_ = _byte_stat_dup0 ((ByteStat*) _tmp2_);
				b = _tmp3_;
				_tmp4_ = b;
				if ((*_tmp4_).total_speed > a) {
					ByteStat* _tmp5_;
					_tmp5_ = b;
					a = (*_tmp5_).total_speed;
				}
				_byte_stat_free0 (b);
			}
		}
	}
	result = a;
	return result;
}

gboolean
status_icon_if_update_scale (StatusIconIF* self)
{
	gboolean result = FALSE;
	gint height = 0;
	cairo_surface_t* _tmp0_;
	gdouble total = 0.0;
	IFace* _tmp1_;
	GQueue* _tmp2_;
	gfloat port = 0.0F;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->surface;
	height = cairo_image_surface_get_height (_tmp0_);
	_tmp1_ = self->iface;
	_tmp2_ = _tmp1_->flow_queue;
	total = status_icon_if_max_total_speed (self, _tmp2_);
	port = self->portion;
	if (total < ((gdouble) self->rate_low)) {
		port = self->portion_low;
	}
	if (total > fdelta) {
		gdouble lscale = 0.0;
		gboolean _tmp3_ = FALSE;
		gboolean _tmp4_ = FALSE;
		lscale = (height * port) / total;
		if (self->priv->scale < (-fdelta)) {
			_tmp4_ = TRUE;
		} else {
			gboolean _tmp5_ = FALSE;
			if (self->priv->scale > fdelta) {
				_tmp5_ = (fabs (self->priv->scale - lscale) / self->priv->scale) > 0.3;
			} else {
				_tmp5_ = FALSE;
			}
			_tmp4_ = _tmp5_;
		}
		if (_tmp4_) {
			_tmp3_ = TRUE;
		} else {
			_tmp3_ = ((gdouble) height) < (self->priv->scale * total);
		}
		if (_tmp3_) {
			self->priv->scale = lscale;
		}
	}
	result = TRUE;
	return result;
}

static gdouble*
_vala_array_dup1 (gdouble* self,
                  int length)
{
	return g_memdup (self, length * sizeof (gdouble));
}

static gdouble*
_vala_array_dup2 (gdouble* self,
                  int length)
{
	return g_memdup (self, length * sizeof (gdouble));
}

static void
status_icon_if_get_speed (StatusIconIF* self,
                          gdouble max_speed,
                          StatusIconIFTransSpeed* result)
{
	gdouble* rx_list = NULL;
	IFace* _tmp0_;
	GQueue* _tmp1_;
	gdouble* _tmp2_;
	gint rx_list_length1;
	gint _rx_list_size_;
	gdouble* tx_list = NULL;
	IFace* _tmp3_;
	GQueue* _tmp4_;
	gdouble* _tmp5_;
	gint tx_list_length1;
	gint _tx_list_size_;
	gdouble lscale = 0.0;
	StatusIconIFTransSpeed ret = {0};
	gdouble* _tmp19_;
	gint _tmp19__length1;
	gdouble* _tmp20_;
	gint _tmp20__length1;
	gdouble* _tmp21_;
	gint _tmp21__length1;
	gdouble* _tmp22_;
	gint _tmp22__length1;
	StatusIconIFTransSpeed _tmp23_ = {0};
	g_return_if_fail (self != NULL);
	_tmp0_ = self->iface;
	_tmp1_ = _tmp0_->flow_queue;
	_tmp2_ = g_new0 (gdouble, _tmp1_->length);
	rx_list = _tmp2_;
	rx_list_length1 = _tmp1_->length;
	_rx_list_size_ = rx_list_length1;
	_tmp3_ = self->iface;
	_tmp4_ = _tmp3_->flow_queue;
	_tmp5_ = g_new0 (gdouble, _tmp4_->length);
	tx_list = _tmp5_;
	tx_list_length1 = _tmp4_->length;
	_tx_list_size_ = tx_list_length1;
	if (self->priv->scale < (-fdelta)) {
		status_icon_if_update_scale (self);
	}
	if (self->priv->scale < (-fdelta)) {
		lscale = 1.0;
	} else {
		lscale = self->priv->scale;
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp6_ = FALSE;
			_tmp6_ = TRUE;
			while (TRUE) {
				IFace* _tmp8_;
				GQueue* _tmp9_;
				ByteStat* statn = NULL;
				IFace* _tmp10_;
				GQueue* _tmp11_;
				gconstpointer _tmp12_;
				ByteStat* _tmp13_;
				gdouble rspeed = 0.0;
				ByteStat* _tmp14_;
				gdouble tspeed = 0.0;
				ByteStat* _tmp15_;
				if (!_tmp6_) {
					gint _tmp7_;
					_tmp7_ = i;
					i = _tmp7_ + 1;
				}
				_tmp6_ = FALSE;
				_tmp8_ = self->iface;
				_tmp9_ = _tmp8_->flow_queue;
				if (!(((guint) i) < _tmp9_->length)) {
					break;
				}
				_tmp10_ = self->iface;
				_tmp11_ = _tmp10_->flow_queue;
				_tmp12_ = g_queue_peek_nth (_tmp11_, (guint) i);
				_tmp13_ = _byte_stat_dup0 ((ByteStat*) _tmp12_);
				statn = _tmp13_;
				_tmp14_ = statn;
				rspeed = (*_tmp14_).rx_speed * lscale;
				_tmp15_ = statn;
				tspeed = (*_tmp15_).tx_speed * lscale;
				if ((rspeed + tspeed) > max_speed) {
					StatusIconIFTransSpeed _tmp16_ = {0};
					status_icon_if_update_scale (self);
					status_icon_if_get_speed (self, max_speed, &_tmp16_);
					*result = _tmp16_;
					_byte_stat_free0 (statn);
					tx_list = (g_free (tx_list), NULL);
					rx_list = (g_free (rx_list), NULL);
					return;
				} else {
					gdouble* _tmp17_;
					gint _tmp17__length1;
					gdouble* _tmp18_;
					gint _tmp18__length1;
					_tmp17_ = rx_list;
					_tmp17__length1 = rx_list_length1;
					_tmp17_[i] = rspeed;
					_tmp18_ = tx_list;
					_tmp18__length1 = tx_list_length1;
					_tmp18_[i] = tspeed;
				}
				_byte_stat_free0 (statn);
			}
		}
	}
	_tmp19_ = rx_list;
	_tmp19__length1 = rx_list_length1;
	_tmp20_ = (_tmp19_ != NULL) ? _vala_array_dup1 (_tmp19_, _tmp19__length1) : ((gpointer) _tmp19_);
	_tmp20__length1 = _tmp19__length1;
	_tmp21_ = tx_list;
	_tmp21__length1 = tx_list_length1;
	_tmp22_ = (_tmp21_ != NULL) ? _vala_array_dup2 (_tmp21_, _tmp21__length1) : ((gpointer) _tmp21_);
	_tmp22__length1 = _tmp21__length1;
	memset (&_tmp23_, 0, sizeof (StatusIconIFTransSpeed));
	_tmp23_.rx_list = (g_free (_tmp23_.rx_list), NULL);
	_tmp23_.rx_list = _tmp20_;
	_tmp23_.rx_list_length1 = _tmp20__length1;
	_tmp23_._rx_list_size_ = _tmp23_.rx_list_length1;
	_tmp23_.tx_list = (g_free (_tmp23_.tx_list), NULL);
	_tmp23_.tx_list = _tmp22_;
	_tmp23_.tx_list_length1 = _tmp22__length1;
	_tmp23_._tx_list_size_ = _tmp23_.tx_list_length1;
	ret = _tmp23_;
	*result = ret;
	tx_list = (g_free (tx_list), NULL);
	rx_list = (g_free (rx_list), NULL);
	return;
}

static gint
status_icon_if_color_index_by_speed (StatusIconIF* self,
                                     gdouble current_speed)
{
	gint result = 0;
	gint speed_color_id = 0;
	g_return_val_if_fail (self != NULL, 0);
	speed_color_id = 0;
	{
		gint i = 0;
		guint* _tmp0_;
		gint _tmp0__length1;
		_tmp0_ = self->priv->color_step;
		_tmp0__length1 = self->priv->color_step_length1;
		i = _tmp0__length1 - 1;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				guint* _tmp3_;
				gint _tmp3__length1;
				guint _tmp4_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ - 1;
				}
				_tmp1_ = FALSE;
				if (!(i > 0)) {
					break;
				}
				_tmp3_ = self->priv->color_step;
				_tmp3__length1 = self->priv->color_step_length1;
				_tmp4_ = _tmp3_[i];
				if (current_speed >= ((gdouble) _tmp4_)) {
					speed_color_id = i;
					break;
				}
			}
		}
	}
	result = speed_color_id;
	return result;
}

static gdouble*
_vala_array_dup3 (gdouble* self,
                  int length)
{
	return g_memdup (self, length * sizeof (gdouble));
}

static gdouble*
_vala_array_dup4 (gdouble* self,
                  int length)
{
	return g_memdup (self, length * sizeof (gdouble));
}

gboolean
status_icon_if_update (StatusIconIF* self)
{
	gboolean result = FALSE;
	cairo_t* _tmp0_;
	IFace* _tmp1_;
	gchar* tooltxt = NULL;
	gchar* _tmp2_;
	GtkStatusIcon* _tmp3_;
	const gchar* _tmp4_;
	gint graph_width = 0;
	cairo_surface_t* _tmp5_;
	gint graph_height = 0;
	cairo_surface_t* _tmp6_;
	StatusIconIFTransSpeed ls = {0};
	StatusIconIFTransSpeed _tmp7_ = {0};
	gdouble* rx_list = NULL;
	StatusIconIFTransSpeed _tmp8_;
	gdouble* _tmp9_;
	gint _tmp9__length1;
	gdouble* _tmp10_;
	gint _tmp10__length1;
	gint rx_list_length1;
	gint _rx_list_size_;
	gdouble* tx_list = NULL;
	StatusIconIFTransSpeed _tmp11_;
	gdouble* _tmp12_;
	gint _tmp12__length1;
	gdouble* _tmp13_;
	gint _tmp13__length1;
	gint tx_list_length1;
	gint _tx_list_size_;
	gfloat slow_width = 0.0F;
	IFace* _tmp14_;
	guint xoffset = 0U;
	IFace* _tmp15_;
	gdouble* _tmp16_;
	gint _tmp16__length1;
	cairo_t* _tmp17_;
	cairo_t* _tmp18_;
	gint color_id = 0;
	GdkRGBA color = {0};
	cairo_t* _tmp45_;
	GdkPixbuf* pixbuf = NULL;
	cairo_surface_t* _tmp46_;
	GdkPixbuf* _tmp47_;
	GtkStatusIcon* _tmp48_;
	GdkPixbuf* _tmp49_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->ctx;
	if (_tmp0_ == NULL) {
		result = TRUE;
		return result;
	}
	_tmp1_ = self->iface;
	iface_update (_tmp1_);
	_tmp2_ = status_icon_if_make_tooltip (self);
	tooltxt = _tmp2_;
	_tmp3_ = self->priv->statusicon;
	_tmp4_ = tooltxt;
	gtk_status_icon_set_tooltip_text (_tmp3_, _tmp4_);
	_tmp5_ = self->priv->surface;
	graph_width = cairo_image_surface_get_width (_tmp5_);
	_tmp6_ = self->priv->surface;
	graph_height = cairo_image_surface_get_height (_tmp6_);
	status_icon_if_get_speed (self, (gdouble) graph_height, &_tmp7_);
	ls = _tmp7_;
	_tmp8_ = ls;
	_tmp9_ = _tmp8_.rx_list;
	_tmp9__length1 = _tmp8_.rx_list_length1;
	_tmp10_ = (_tmp9_ != NULL) ? _vala_array_dup3 (_tmp9_, _tmp9__length1) : ((gpointer) _tmp9_);
	_tmp10__length1 = _tmp9__length1;
	rx_list = _tmp10_;
	rx_list_length1 = _tmp10__length1;
	_rx_list_size_ = rx_list_length1;
	_tmp11_ = ls;
	_tmp12_ = _tmp11_.tx_list;
	_tmp12__length1 = _tmp11_.tx_list_length1;
	_tmp13_ = (_tmp12_ != NULL) ? _vala_array_dup4 (_tmp12_, _tmp12__length1) : ((gpointer) _tmp12_);
	_tmp13__length1 = _tmp12__length1;
	tx_list = _tmp13_;
	tx_list_length1 = _tmp13__length1;
	_tx_list_size_ = tx_list_length1;
	_tmp14_ = self->iface;
	slow_width = ((gfloat) graph_width) / _tmp14_->maxlen;
	_tmp15_ = self->iface;
	_tmp16_ = rx_list;
	_tmp16__length1 = rx_list_length1;
	xoffset = _tmp15_->maxlen - _tmp16__length1;
	_tmp17_ = self->priv->ctx;
	cairo_paint (_tmp17_);
	_tmp18_ = self->priv->ctx;
	cairo_save (_tmp18_);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp19_ = FALSE;
			_tmp19_ = TRUE;
			while (TRUE) {
				gdouble* _tmp21_;
				gint _tmp21__length1;
				gdouble speed = 0.0;
				gdouble* _tmp22_;
				gint _tmp22__length1;
				gdouble _tmp23_;
				GdkRGBA* _tmp24_;
				gint _tmp24__length1;
				GdkRGBA _tmp25_;
				cairo_t* _tmp26_;
				GdkRGBA _tmp27_;
				GdkRGBA _tmp28_;
				GdkRGBA _tmp29_;
				cairo_t* _tmp30_;
				cairo_t* _tmp31_;
				if (!_tmp19_) {
					gint _tmp20_;
					_tmp20_ = i;
					i = _tmp20_ + 1;
				}
				_tmp19_ = FALSE;
				_tmp21_ = rx_list;
				_tmp21__length1 = rx_list_length1;
				if (!(i < _tmp21__length1)) {
					break;
				}
				_tmp22_ = rx_list;
				_tmp22__length1 = rx_list_length1;
				_tmp23_ = _tmp22_[i];
				speed = _tmp23_;
				color_id = status_icon_if_color_index_by_speed (self, speed / self->priv->scale);
				_tmp24_ = self->priv->rx_colors;
				_tmp24__length1 = self->priv->rx_colors_length1;
				_tmp25_ = _tmp24_[color_id];
				color = _tmp25_;
				_tmp26_ = self->priv->ctx;
				_tmp27_ = color;
				_tmp28_ = color;
				_tmp29_ = color;
				cairo_set_source_rgb (_tmp26_, _tmp27_.red, _tmp28_.green, _tmp29_.blue);
				_tmp30_ = self->priv->ctx;
				cairo_rectangle (_tmp30_, (gdouble) (slow_width * (i + xoffset)), graph_height - speed, (gdouble) slow_width, speed);
				_tmp31_ = self->priv->ctx;
				cairo_fill (_tmp31_);
			}
		}
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp32_ = FALSE;
			_tmp32_ = TRUE;
			while (TRUE) {
				gdouble* _tmp34_;
				gint _tmp34__length1;
				gdouble speed = 0.0;
				gdouble* _tmp35_;
				gint _tmp35__length1;
				gdouble _tmp36_;
				GdkRGBA* _tmp37_;
				gint _tmp37__length1;
				GdkRGBA _tmp38_;
				cairo_t* _tmp39_;
				GdkRGBA _tmp40_;
				GdkRGBA _tmp41_;
				GdkRGBA _tmp42_;
				cairo_t* _tmp43_;
				cairo_t* _tmp44_;
				if (!_tmp32_) {
					gint _tmp33_;
					_tmp33_ = i;
					i = _tmp33_ + 1;
				}
				_tmp32_ = FALSE;
				_tmp34_ = tx_list;
				_tmp34__length1 = tx_list_length1;
				if (!(i < _tmp34__length1)) {
					break;
				}
				_tmp35_ = tx_list;
				_tmp35__length1 = tx_list_length1;
				_tmp36_ = _tmp35_[i];
				speed = _tmp36_;
				color_id = status_icon_if_color_index_by_speed (self, speed / self->priv->scale);
				_tmp37_ = self->priv->tx_colors;
				_tmp37__length1 = self->priv->tx_colors_length1;
				_tmp38_ = _tmp37_[color_id];
				color = _tmp38_;
				_tmp39_ = self->priv->ctx;
				_tmp40_ = color;
				_tmp41_ = color;
				_tmp42_ = color;
				cairo_set_source_rgb (_tmp39_, _tmp40_.red, _tmp41_.green, _tmp42_.blue);
				_tmp43_ = self->priv->ctx;
				cairo_rectangle (_tmp43_, (gdouble) (slow_width * (i + xoffset)), (gdouble) 0, (gdouble) slow_width, speed);
				_tmp44_ = self->priv->ctx;
				cairo_fill (_tmp44_);
			}
		}
	}
	_tmp45_ = self->priv->ctx;
	cairo_restore (_tmp45_);
	_tmp46_ = self->priv->surface;
	_tmp47_ = gdk_pixbuf_get_from_surface (_tmp46_, 0, 0, graph_width, graph_height);
	pixbuf = _tmp47_;
	_tmp48_ = self->priv->statusicon;
	_tmp49_ = pixbuf;
	gtk_status_icon_set_from_pixbuf (_tmp48_, _tmp49_);
	result = TRUE;
	_g_object_unref0 (pixbuf);
	tx_list = (g_free (tx_list), NULL);
	rx_list = (g_free (rx_list), NULL);
	status_icon_if_trans_speed_destroy (&ls);
	_g_free0 (tooltxt);
	return result;
}

static gboolean
_status_icon_if_update_gsource_func (gpointer self)
{
	gboolean result;
	result = status_icon_if_update ((StatusIconIF*) self);
	return result;
}

void
status_icon_if_start_timers (StatusIconIF* self)
{
	g_return_if_fail (self != NULL);
	self->priv->update_id = g_timeout_add_full (G_PRIORITY_DEFAULT, self->update_timeout, _status_icon_if_update_gsource_func, g_object_ref (self), g_object_unref);
	self->priv->update_scale_id = g_timeout_add_full (G_PRIORITY_DEFAULT, self->update_scale_timeout, _status_icon_if_update_scale_gsource_func, g_object_ref (self), g_object_unref);
}

void
status_icon_if_on_quit (StatusIconIF* self,
                        GtkAction* act)
{
	Application* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (act != NULL);
	_tmp0_ = self->priv->app;
	application_quit (_tmp0_);
}

void
status_icon_if_on_destroy (StatusIconIF* self)
{
	g_return_if_fail (self != NULL);
	g_source_remove (self->priv->update_id);
	g_source_remove (self->priv->update_scale_id);
}

static gdouble*
_vala_array_dup5 (gdouble* self,
                  int length)
{
	return g_memdup (self, length * sizeof (gdouble));
}

static gdouble*
_vala_array_dup6 (gdouble* self,
                  int length)
{
	return g_memdup (self, length * sizeof (gdouble));
}

static void
status_icon_if_trans_speed_copy (const StatusIconIFTransSpeed* self,
                                 StatusIconIFTransSpeed* dest)
{
	gdouble* _tmp0_;
	gint _tmp0__length1;
	gdouble* _tmp1_;
	gint _tmp1__length1;
	gdouble* _tmp2_;
	gint _tmp2__length1;
	gdouble* _tmp3_;
	gint _tmp3__length1;
	_tmp0_ = (*self).rx_list;
	_tmp0__length1 = (*self).rx_list_length1;
	_tmp1_ = (_tmp0_ != NULL) ? _vala_array_dup5 (_tmp0_, _tmp0__length1) : ((gpointer) _tmp0_);
	_tmp1__length1 = _tmp0__length1;
	(*dest).rx_list = (g_free ((*dest).rx_list), NULL);
	(*dest).rx_list = _tmp1_;
	(*dest).rx_list_length1 = _tmp1__length1;
	(*dest)._rx_list_size_ = (*dest).rx_list_length1;
	_tmp2_ = (*self).tx_list;
	_tmp2__length1 = (*self).tx_list_length1;
	_tmp3_ = (_tmp2_ != NULL) ? _vala_array_dup6 (_tmp2_, _tmp2__length1) : ((gpointer) _tmp2_);
	_tmp3__length1 = _tmp2__length1;
	(*dest).tx_list = (g_free ((*dest).tx_list), NULL);
	(*dest).tx_list = _tmp3_;
	(*dest).tx_list_length1 = _tmp3__length1;
	(*dest)._tx_list_size_ = (*dest).tx_list_length1;
}

static void
status_icon_if_trans_speed_destroy (StatusIconIFTransSpeed* self)
{
	(*self).rx_list = (g_free ((*self).rx_list), NULL);
	(*self).tx_list = (g_free ((*self).tx_list), NULL);
}

static StatusIconIFTransSpeed*
status_icon_if_trans_speed_dup (const StatusIconIFTransSpeed* self)
{
	StatusIconIFTransSpeed* dup;
	dup = g_new0 (StatusIconIFTransSpeed, 1);
	status_icon_if_trans_speed_copy (self, dup);
	return dup;
}

static void
status_icon_if_trans_speed_free (StatusIconIFTransSpeed* self)
{
	status_icon_if_trans_speed_destroy (self);
	g_free (self);
}

static GType
status_icon_if_trans_speed_get_type (void)
{
	static volatile gsize status_icon_if_trans_speed_type_id__volatile = 0;
	if (g_once_init_enter (&status_icon_if_trans_speed_type_id__volatile)) {
		GType status_icon_if_trans_speed_type_id;
		status_icon_if_trans_speed_type_id = g_boxed_type_register_static ("StatusIconIFTransSpeed", (GBoxedCopyFunc) status_icon_if_trans_speed_dup, (GBoxedFreeFunc) status_icon_if_trans_speed_free);
		g_once_init_leave (&status_icon_if_trans_speed_type_id__volatile, status_icon_if_trans_speed_type_id);
	}
	return status_icon_if_trans_speed_type_id__volatile;
}

static void
status_icon_if_class_init (StatusIconIFClass * klass,
                           gpointer klass_data)
{
	status_icon_if_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &StatusIconIF_private_offset);
	G_OBJECT_CLASS (klass)->finalize = status_icon_if_finalize;
}

static void
status_icon_if_instance_init (StatusIconIF * self,
                              gpointer klass)
{
	guint* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar** _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gchar** _tmp12_;
	GdkRGBA* _tmp13_;
	GdkRGBA* _tmp14_;
	self->priv = status_icon_if_get_instance_private (self);
	self->priv->ctx = NULL;
	self->priv->scale = -1.0;
	self->priv->update_id = (guint) -1;
	self->priv->update_scale_id = (guint) -1;
	self->priv->margin = 1;
	self->portion = 0.8f;
	self->portion_low = 0.3f;
	self->rate_low = 1024.0f;
	self->update_timeout = (guint) 1000;
	_tmp0_ = g_new0 (guint, 5);
	_tmp0_[0] = (guint) 0x0;
	_tmp0_[1] = (guint) 0x400;
	_tmp0_[2] = (guint) 0x2800;
	_tmp0_[3] = (guint) 0x100000;
	_tmp0_[4] = (guint) 0x990000;
	self->priv->color_step = _tmp0_;
	self->priv->color_step_length1 = 5;
	self->priv->_color_step_size_ = self->priv->color_step_length1;
	_tmp1_ = g_strdup ("#0ea5fd");
	_tmp2_ = g_strdup ("#03fc83");
	_tmp3_ = g_strdup ("#c1fa07");
	_tmp4_ = g_strdup ("#f908fa");
	_tmp5_ = g_strdup ("#fc0527");
	_tmp6_ = g_new0 (gchar*, 5 + 1);
	_tmp6_[0] = _tmp1_;
	_tmp6_[1] = _tmp2_;
	_tmp6_[2] = _tmp3_;
	_tmp6_[3] = _tmp4_;
	_tmp6_[4] = _tmp5_;
	self->priv->rx_color_strings = _tmp6_;
	self->priv->rx_color_strings_length1 = 5;
	self->priv->_rx_color_strings_size_ = self->priv->rx_color_strings_length1;
	_tmp7_ = g_strdup ("#057cc0");
	_tmp8_ = g_strdup ("#05c065");
	_tmp9_ = g_strdup ("#99bf1c");
	_tmp10_ = g_strdup ("#af03b0");
	_tmp11_ = g_strdup ("#c43b4e");
	_tmp12_ = g_new0 (gchar*, 5 + 1);
	_tmp12_[0] = _tmp7_;
	_tmp12_[1] = _tmp8_;
	_tmp12_[2] = _tmp9_;
	_tmp12_[3] = _tmp10_;
	_tmp12_[4] = _tmp11_;
	self->priv->tx_color_strings = _tmp12_;
	self->priv->tx_color_strings_length1 = 5;
	self->priv->_tx_color_strings_size_ = self->priv->tx_color_strings_length1;
	_tmp13_ = g_new0 (GdkRGBA, 0);
	self->priv->rx_colors = _tmp13_;
	self->priv->rx_colors_length1 = 0;
	self->priv->_rx_colors_size_ = self->priv->rx_colors_length1;
	_tmp14_ = g_new0 (GdkRGBA, 0);
	self->priv->tx_colors = _tmp14_;
	self->priv->tx_colors_length1 = 0;
	self->priv->_tx_colors_size_ = self->priv->tx_colors_length1;
}

static void
status_icon_if_finalize (GObject * obj)
{
	StatusIconIF * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_STATUS_ICON_IF, StatusIconIF);
	_g_object_unref0 (self->priv->app);
	_cairo_destroy0 (self->priv->ctx);
	_cairo_surface_destroy0 (self->priv->surface);
	_g_object_unref0 (self->priv->statusicon);
	_g_object_unref0 (self->priv->menu);
	_g_object_unref0 (self->iface);
	self->priv->color_step = (g_free (self->priv->color_step), NULL);
	self->priv->rx_color_strings = (_vala_array_free (self->priv->rx_color_strings, self->priv->rx_color_strings_length1, (GDestroyNotify) g_free), NULL);
	self->priv->tx_color_strings = (_vala_array_free (self->priv->tx_color_strings, self->priv->tx_color_strings_length1, (GDestroyNotify) g_free), NULL);
	self->priv->rx_colors = (g_free (self->priv->rx_colors), NULL);
	self->priv->tx_colors = (g_free (self->priv->tx_colors), NULL);
	G_OBJECT_CLASS (status_icon_if_parent_class)->finalize (obj);
}

GType
status_icon_if_get_type (void)
{
	static volatile gsize status_icon_if_type_id__volatile = 0;
	if (g_once_init_enter (&status_icon_if_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (StatusIconIFClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) status_icon_if_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (StatusIconIF), 0, (GInstanceInitFunc) status_icon_if_instance_init, NULL };
		GType status_icon_if_type_id;
		status_icon_if_type_id = g_type_register_static (G_TYPE_OBJECT, "StatusIconIF", &g_define_type_info, 0);
		StatusIconIF_private_offset = g_type_add_instance_private (status_icon_if_type_id, sizeof (StatusIconIFPrivate));
		g_once_init_leave (&status_icon_if_type_id__volatile, status_icon_if_type_id);
	}
	return status_icon_if_type_id__volatile;
}

static inline gpointer
application_get_instance_private (Application* self)
{
	return G_STRUCT_MEMBER_P (self, Application_private_offset);
}

static gint
__lambda4_ (Application* self,
            const gchar* a,
            const gchar* b)
{
	gint result = 0;
	GCompareFunc _tmp0_;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp0_ = ((GCompareFunc) g_strcmp0);
	result = _tmp0_ (a, b);
	return result;
}

static gint
___lambda4__gcompare_data_func (gconstpointer a,
                                gconstpointer b,
                                gpointer self)
{
	gint result;
	result = __lambda4_ ((Application*) self, (const gchar*) a, (const gchar*) b);
	return result;
}

static void
_g_object_unref_gdestroy_notify (void* data)
{
	g_object_unref (data);
}

static Application*
application_construct (GType object_type)
{
	Application * self = NULL;
	GDestroyNotify _tmp0_;
	GTree* _tmp1_;
	self = (Application*) g_object_new (object_type, NULL);
	_tmp0_ = g_free;
	_tmp1_ = g_tree_new_full (___lambda4__gcompare_data_func, self, _tmp0_, _g_object_unref_gdestroy_notify);
	_g_tree_unref0 (self->priv->iface_map);
	self->priv->iface_map = _tmp1_;
	return self;
}

static Application*
application_new (void)
{
	return application_construct (TYPE_APPLICATION);
}

static Block1Data*
block1_data_ref (Block1Data* _data1_)
{
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}

static void
block1_data_unref (void * _userdata_)
{
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		Application* self;
		self = _data1_->self;
		_data1_->key2remove = (_vala_array_free (_data1_->key2remove, _data1_->key2remove_length1, (GDestroyNotify) g_free), NULL);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}

static void
_vala_array_add3 (gchar** * array,
                  int* length,
                  int* size,
                  gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}

static gboolean
__lambda5_ (Block1Data* _data1_,
            const gchar* k,
            StatusIconIF* v)
{
	Application* self;
	gboolean result = FALSE;
	StatusIconIF* v1 = NULL;
	StatusIconIF* _tmp0_;
	StatusIconIF* _tmp1_;
	IFace* _tmp2_;
	gboolean _tmp3_;
	gboolean _tmp4_;
	self = _data1_->self;
	g_return_val_if_fail (k != NULL, FALSE);
	g_return_val_if_fail (v != NULL, FALSE);
	_tmp0_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (v, TYPE_STATUS_ICON_IF) ? ((StatusIconIF*) v) : NULL);
	v1 = _tmp0_;
	_tmp1_ = v1;
	_tmp2_ = _tmp1_->iface;
	_tmp3_ = iface_get_isup (_tmp2_);
	_tmp4_ = _tmp3_;
	if (!_tmp4_) {
		gchar** _tmp5_;
		gint _tmp5__length1;
		gchar* _tmp6_;
		_tmp5_ = _data1_->key2remove;
		_tmp5__length1 = _data1_->key2remove_length1;
		_tmp6_ = g_strdup ((const gchar*) k);
		_vala_array_add3 (&_data1_->key2remove, &_data1_->key2remove_length1, &_data1_->_key2remove_size_, _tmp6_);
	}
	result = FALSE;
	_g_object_unref0 (v1);
	return result;
}

static gboolean
___lambda5__gtraverse_func (gconstpointer key,
                            gconstpointer value,
                            gpointer self)
{
	gboolean result;
	result = __lambda5_ (self, (const gchar*) key, (StatusIconIF*) value);
	return result;
}

static gboolean
application_update_iface (Application* self)
{
	gboolean result = FALSE;
	Block1Data* _data1_;
	gchar** _tmp34_;
	GTree* _tmp35_;
	gchar** _tmp36_;
	gint _tmp36__length1;
	GError* _inner_error0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	{
		GFile* root = NULL;
		GFile* _tmp0_;
		GFileEnumerator* root_enum = NULL;
		GFile* _tmp1_;
		GFileEnumerator* _tmp2_;
		GFileInfo* file_info = NULL;
		_tmp0_ = g_file_new_for_path (SYS_NET_PATH);
		root = _tmp0_;
		_tmp1_ = root;
		_tmp2_ = g_file_enumerate_children (_tmp1_, G_FILE_ATTRIBUTE_STANDARD_NAME, 0, NULL, &_inner_error0_);
		root_enum = _tmp2_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (root);
			goto __catch3_g_error;
		}
		while (TRUE) {
			GFileInfo* _tmp3_ = NULL;
			GFileEnumerator* _tmp4_;
			GFileInfo* _tmp5_;
			GFileInfo* _tmp6_;
			GFileInfo* _tmp7_;
			gchar* fid = NULL;
			GFileInfo* _tmp8_;
			const gchar* _tmp9_;
			gchar* _tmp10_;
			gboolean _tmp11_ = FALSE;
			const gchar* _tmp12_;
			_tmp4_ = root_enum;
			_tmp5_ = g_file_enumerator_next_file (_tmp4_, NULL, &_inner_error0_);
			_tmp3_ = _tmp5_;
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				_g_object_unref0 (file_info);
				_g_object_unref0 (root_enum);
				_g_object_unref0 (root);
				goto __catch3_g_error;
			}
			_tmp6_ = _tmp3_;
			_tmp3_ = NULL;
			_g_object_unref0 (file_info);
			file_info = _tmp6_;
			_tmp7_ = file_info;
			if (!(_tmp7_ != NULL)) {
				_g_object_unref0 (_tmp3_);
				break;
			}
			_tmp8_ = file_info;
			_tmp9_ = g_file_info_get_name (_tmp8_);
			_tmp10_ = g_strdup (_tmp9_);
			fid = _tmp10_;
			_tmp12_ = fid;
			if (g_strcmp0 (_tmp12_, "lo") != 0) {
				GTree* _tmp13_;
				const gchar* _tmp14_;
				gconstpointer _tmp15_;
				_tmp13_ = self->priv->iface_map;
				_tmp14_ = fid;
				_tmp15_ = g_tree_lookup (_tmp13_, _tmp14_);
				_tmp11_ = ((StatusIconIF*) _tmp15_) == NULL;
			} else {
				_tmp11_ = FALSE;
			}
			if (_tmp11_) {
				IFace* iface = NULL;
				const gchar* _tmp16_;
				IFace* _tmp17_;
				IFace* _tmp18_;
				gboolean _tmp19_;
				gboolean _tmp20_;
				_tmp16_ = fid;
				_tmp17_ = iface_new (_tmp16_);
				iface = _tmp17_;
				_tmp18_ = iface;
				_tmp19_ = iface_get_isup (_tmp18_);
				_tmp20_ = _tmp19_;
				if (_tmp20_) {
					StatusIconIF* v = NULL;
					IFace* _tmp21_;
					StatusIconIF* _tmp22_;
					StatusIconIF* _tmp23_;
					StatusIconIF* _tmp24_;
					GTree* _tmp25_;
					const gchar* _tmp26_;
					gchar* _tmp27_;
					StatusIconIF* _tmp28_;
					StatusIconIF* _tmp29_;
					_tmp21_ = iface;
					_tmp22_ = status_icon_if_new (self, _tmp21_);
					v = _tmp22_;
					_tmp23_ = v;
					status_icon_if_start_timers (_tmp23_);
					_tmp24_ = v;
					status_icon_if_update (_tmp24_);
					_tmp25_ = self->priv->iface_map;
					_tmp26_ = fid;
					_tmp27_ = g_strdup (_tmp26_);
					_tmp28_ = v;
					_tmp29_ = _g_object_ref0 (_tmp28_);
					g_tree_insert (_tmp25_, _tmp27_, _tmp29_);
					_g_object_unref0 (v);
				}
				_g_object_unref0 (iface);
			}
			_g_free0 (fid);
			_g_object_unref0 (_tmp3_);
		}
		_g_object_unref0 (file_info);
		_g_object_unref0 (root_enum);
		_g_object_unref0 (root);
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* e = NULL;
		FILE* _tmp30_;
		GError* _tmp31_;
		const gchar* _tmp32_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp30_ = stderr;
		_tmp31_ = e;
		_tmp32_ = _tmp31_->message;
		fprintf (_tmp30_, "Error: %s\n", _tmp32_);
		_g_error_free0 (e);
	}
	__finally3:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		gboolean _tmp33_ = FALSE;
		block1_data_unref (_data1_);
		_data1_ = NULL;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return _tmp33_;
	}
	_tmp34_ = g_new0 (gchar*, 0 + 1);
	_data1_->key2remove = _tmp34_;
	_data1_->key2remove_length1 = 0;
	_data1_->_key2remove_size_ = _data1_->key2remove_length1;
	_tmp35_ = self->priv->iface_map;
	g_tree_foreach (_tmp35_, ___lambda5__gtraverse_func, _data1_);
	_tmp36_ = _data1_->key2remove;
	_tmp36__length1 = _data1_->key2remove_length1;
	{
		gchar** k_collection = NULL;
		gint k_collection_length1 = 0;
		gint _k_collection_size_ = 0;
		gint k_it = 0;
		k_collection = _tmp36_;
		k_collection_length1 = _tmp36__length1;
		for (k_it = 0; k_it < _tmp36__length1; k_it = k_it + 1) {
			gchar* _tmp37_;
			gchar* k = NULL;
			_tmp37_ = g_strdup (k_collection[k_it]);
			k = _tmp37_;
			{
				GTree* _tmp38_;
				const gchar* _tmp39_;
				gconstpointer _tmp40_;
				GTree* _tmp41_;
				const gchar* _tmp42_;
				_tmp38_ = self->priv->iface_map;
				_tmp39_ = k;
				_tmp40_ = g_tree_lookup (_tmp38_, _tmp39_);
				status_icon_if_on_destroy ((StatusIconIF*) _tmp40_);
				_tmp41_ = self->priv->iface_map;
				_tmp42_ = k;
				g_tree_remove (_tmp41_, _tmp42_);
				_g_free0 (k);
			}
		}
	}
	result = TRUE;
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return result;
}

static void
__lambda6_ (Application* self,
            GtkDialog* a,
            gint b)
{
	g_return_if_fail (a != NULL);
	g_signal_handler_disconnect ((GObject*) a, self->priv->about_response_id);
	gtk_widget_destroy ((GtkWidget*) a);
}

static void
___lambda6__gtk_dialog_response (GtkDialog* _sender,
                                 gint response_id,
                                 gpointer self)
{
	__lambda6_ ((Application*) self, _sender, response_id);
}

void
application_on_about_dialog_show (Application* self,
                                  GtkAction* act)
{
	GtkAboutDialog* ad = NULL;
	GtkAboutDialog* _tmp0_;
	gulong _tmp1_;
	static const gchar* authors[1] = {"Mozbugbox"};
	g_return_if_fail (self != NULL);
	g_return_if_fail (act != NULL);
	_tmp0_ = (GtkAboutDialog*) gtk_about_dialog_new ();
	g_object_ref_sink (_tmp0_);
	ad = _tmp0_;
	_tmp1_ = g_signal_connect_object ((GtkDialog*) ad, "response", (GCallback) ___lambda6__gtk_dialog_response, self, 0);
	self->priv->about_response_id = _tmp1_;
	gtk_about_dialog_set_program_name (ad, PACKAGE_NAME);
	gtk_about_dialog_set_version (ad, HGVERSION);
	gtk_about_dialog_set_copyright (ad, "Mozbugbox 2011-2013");
	gtk_about_dialog_set_license_type (ad, GTK_LICENSE_GPL_3_0);
	gtk_about_dialog_set_website (ad, PACKAGE_URL);
	gtk_about_dialog_set_website_label (ad, "Byte On Panel Wiki");
	gtk_about_dialog_set_authors (ad, authors);
	gtk_window_present ((GtkWindow*) ad);
	_g_object_unref0 (ad);
}

static gboolean
_application_update_iface_gsource_func (gpointer self)
{
	gboolean result;
	result = application_update_iface ((Application*) self);
	return result;
}

void
application_start (Application* self)
{
	g_return_if_fail (self != NULL);
	application_update_iface (self);
	g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, self->priv->iface_update_timeout, _application_update_iface_gsource_func, g_object_ref (self), g_object_unref);
	gtk_main ();
}

void
application_quit (Application* self)
{
	g_return_if_fail (self != NULL);
	gtk_main_quit ();
}

gint
application_main (gchar** args,
                  gint args_length1)
{
	gint result = 0;
	Application* app = NULL;
	Application* _tmp0_;
	gtk_init ((gint*) (&args_length1), &args);
	_tmp0_ = application_new ();
	app = _tmp0_;
	application_start (app);
	result = 0;
	_g_object_unref0 (app);
	return result;
}

int
main (int argc,
      char ** argv)
{
	return application_main (argv, argc);
}

static void
application_class_init (ApplicationClass * klass,
                        gpointer klass_data)
{
	application_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &Application_private_offset);
	G_OBJECT_CLASS (klass)->finalize = application_finalize;
}

static void
application_instance_init (Application * self,
                           gpointer klass)
{
	self->priv = application_get_instance_private (self);
	self->priv->iface_update_timeout = (guint) 5;
}

static void
application_finalize (GObject * obj)
{
	Application * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_APPLICATION, Application);
	_g_tree_unref0 (self->priv->iface_map);
	G_OBJECT_CLASS (application_parent_class)->finalize (obj);
}

GType
application_get_type (void)
{
	static volatile gsize application_type_id__volatile = 0;
	if (g_once_init_enter (&application_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ApplicationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) application_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Application), 0, (GInstanceInitFunc) application_instance_init, NULL };
		GType application_type_id;
		application_type_id = g_type_register_static (G_TYPE_OBJECT, "Application", &g_define_type_info, 0);
		Application_private_offset = g_type_add_instance_private (application_type_id, sizeof (ApplicationPrivate));
		g_once_init_leave (&application_type_id__volatile, application_type_id);
	}
	return application_type_id__volatile;
}

static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

